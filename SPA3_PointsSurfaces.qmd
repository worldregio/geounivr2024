---
title: "[SPA3] Des points aux surfaces"
subtitle: "GEO UNIV'R Tunisie 2024"
date: "05/15/2024"
author: "Marianne GuÃ©rois, Malika Madelin"
format:
  html:
    embed-resources: true
    theme: yeti
    smooth-scroll: true
    fontsize: 0.9em
    toc: true
    toc-depth: 2
    toc-title: "."
    bibliography: [bib.bib]
    css: custom.css
    crossrefs-hover: false
execute:
  warning: false
  message: false 
  cache: false   
knitr:
  opts_chunk:
    out.width: "100%"
editor_options: 
  chunk_output_type: console
editor: 
  markdown: 
    wrap: 72
---

![](img/Img_PtsSurf.png)

# Objectifs et mise en place du module

Il est trÃ¨s courant (et de plus en plus) d'avoir des donnÃ©es gÃ©ographiques ponctuelles, du fait des mÃ©thodes de collecte et d'Ã©chantillonnage, de la localisation de nos activitÃ©s et des appareils de mesures (GPS, capteurs IoT, ...). La cartographie des points s'avÃ¨re parfois illisible (quand trop de points), voire limitÃ©e pour dÃ©gager la distribution du phÃ©nomÃ¨ne Ã©tudiÃ©.         
Passer des **points** rÃ©partis dans l'espace Ã  des **surfaces**, c'est-Ã -dire Â«Â **spatialiser**Â Â» , permet de rendre plus attractive la carte produite, de mieux apprÃ©hender la rÃ©partition spatiale et aussi d'estimer des valeurs lÃ  oÃ¹ il n'y a pas eu de mesures. De nombreuses mÃ©thodes, de la Â«Â simpleÂ Â» agrÃ©gation spatiale au krigeage, existent et dÃ©pendent notamment de la nature des donnÃ©es. 

Les **objectifs** de ce module sont (1) de distinguer les **types / familles de mÃ©thodes** selon les donnÃ©es, (2) d'aborder les principales et **comment les faire sous `R`** et (3) de discuter des **avantages/limites**. 
AprÃ¨s la prÃ©sentation des **agrÃ©gations spatiales** (les mÃ©thodes les plus Ã©lÃ©mentaires), nous aborderons les mÃ©thodes de **lissages** selon la nature du phÃ©nomÃ¨ne, discrÃ¨te / continue (cf. EncadrÃ©).



::: {.callout-note collapse="true"}
## PhÃ©nomÃ¨ne discret *vs.* phÃ©nomÃ¨ne continu

Â«Â Un phÃ©nomÃ¨ne est dit **continu** dans lâ€™espace sâ€™il est dÃ©fini en tout point de lâ€™espace gÃ©ographique et que ses propriÃ©tÃ©s varient localement de maniÃ¨re graduelle et structurÃ©e.Â Â» (@caloz_collet2011). Pour autant, il ne peut Ãªtre mesurÃ© en tout point de lâ€™espace, l'espace est alors discrÃ©tisÃ© soit en maille rÃ©guliÃ¨re (ex des pixels d'un modÃ¨le numÃ©rique de terrain, cf. MAR2), soit par des points d'Ã©chantillonnage (ex de la tempÃ©rature mesurÃ©e par des stations mÃ©tÃ©orologiques, de niveaux de piÃ©zomÃ¨tres, etc.). Ã€ l'inverse, un phÃ©nomÃ¨ne discret est identifiable comme un objet occupant une surface donnÃ©e sur le territoire (ex d'un Ã©quipement, d'un gouvernorat, etc.), mÃªme s'il peut Ãªtre dÃ©crit ensuite par un point. 

:::

### PrÃ©-requis mÃ©thodologiques

- Sur l'information gÃ©ographique : connaÃ®tre la diffÃ©rence raster/vecteur et la dÃ©finition des coordonnÃ©es spatiales d'objets gÃ©ographiques
- En statistiques : savoir rÃ©sumer une distribution statistique univariÃ©e, connaÃ®tre la corrÃ©lation et la rÃ©gression


### Packages utilisÃ©s

- [**`sf`**](https://cran.r-project.org/web/packages/sf/index.html){target="_blank"} (et aussi [**`sp`**](https://cran.r-project.org/web/packages/sp/index.html){target="_blank"}) : importer, manipuler et exporter des donnÃ©es gÃ©ographiques vectorielles.[vu LUN1, MAR1...]{style="color:#5396B0;"}. `sf` est plus rÃ©cent et maintenant plus utilisÃ© que `sp`, mais il reste quelques packages qui utilisent encore `sp`  ;
- [**`mapsf`**](https://cran.r-project.org/web/packages/mapsf/index.html){target="_blank"} : pour la cartographie thÃ©matique [vu MAR2...]{style="color:#5396B0;"} ;
- [**`terra`**](https://cran.r-project.org/web/packages/terra/index.html){target="_blank"} : pour une partie des mÃ©thodes d'interpolation des donnÃ©es, dans le monde *raster* [vu MAR2 pour les rasters]{style="color:#5396B0;"} ;
- [**`gstat`**](https://cran.r-project.org/web/packages/gstat/index.html){target="_blank"} : pour les mÃ©thodes gÃ©ostatistiques d'interpolation des donnÃ©es ;
- [**`automap`**](https://cran.r-project.org/web/packages/automap/index.html){target="_blank"} : pour l'automatisation de la mÃ©thode d'interpolation des donnÃ©es Â«Â krigeageÂ Â» .
- [**`spatstat`**](https://cran.r-project.org/web/packages/spatstat/index.html){target="_blank"} (et aussi `cartography`) : qui, au-delÃ  de l'analyse des semis de points, permet aussi d'explorer les lissages de phÃ©nomÃ¨nes discrets.


Installation (si le package n'est pas dÃ©jÃ  installÃ© sur votre machine)
```{r, cache = T, message=F}
# liste des packages nÃ©cessaires
liste_packages <- c("sf", "sp", "mapsf", "terra", "gstat", "automap","spatstat","cartography")
# liste des Ã©ventuels packages Ã  installer (= ceux qui ne sont pas dÃ©jÃ  installÃ©s)
new_packages <- liste_packages[!(liste_packages %in% installed.packages()[,"Package"])]
# s'il y en a, installation 
if(length(new_packages)) install.packages(new_packages)
```

Chargement des packages
```{r, cache = T, message=F}
library(sf)
library(sp)
library(mapsf)
library(terra)
library(gstat)
library(automap)
library(spatstat)
library(cartography)
```

<br>

### Importation des bases de donnÃ©es


::: {.callout-tip}
## TÃ©lÃ©charger les jeux de donnÃ©es
-  [SPA](https://github.com/worldregio/geounivr2024/raw/refs/heads/main/datazip/SPA.zip)
-  [SPA3](https://github.com/worldregio/geounivr2024/raw/refs/heads/main/datazip/SPA3.zip)
:::


**Fond de carte des dÃ©lÃ©gations, gouvernorats et rÃ©gions (source: INS & Syfacte/RIATE)**   
DÃ©jÃ  vu dans de [nombreux modules]{style="color:#5396B0;"}.
```{r}
reg <- st_read("data/SPA/tun_admin.gpkg", layer = "region", quiet = TRUE)
```


**DonnÃ©es Tirs au but**  
Les donnÃ©es *Tirs au but* regroupent les localisations des tirs ayant eu lieu lors des matchs des 5 plus grandes ligues europÃ©ennes de football (Angleterre, Espagne, Allemagne, Italie, France). Le fichier initial, disponible [ici](https://github.com/hadjdeh/football-data-analysis/tree/main/Shots_and_goals_map){target="_blank"}. Chaque tir est aussi dÃ©crit par de multiples variables (en tout, le fichier comprend 265 colonnes), sur le type de tir, but ou pas, sur le joueur, l'heure, l'action d'avant, etc.). Le fichier dÃ©crit la saison 2023-24 (plus prÃ©cisÃ©ment du 11/8/23 au 17/3/24). Pour les *aficionados*, vous trouverez au-delÃ  des donnÃ©es, des ressources, des idÃ©es de traitement, etc. sur ce compte de Mikhail Borodasto (github : [hadjdeh](https://github.com/hadjdeh){target="_blank"}).

```{r}
tirsfoot <- read.csv("data/SPA3/event_data_top5_leagues_18032024_(shots).csv")
dim(tirsfoot)

head(tirsfoot[c(100,3000,10000,20000,30000),
              c("id", "startTime", "minute", "x","y", "venueName",
                "type", "playerName", "teamName","score")], )

```


**DonnÃ©es climatiques de la Tunisie**  
DÃ©jÃ  vu dans [STA3 : Statistique MultivariÃ©e]{style="color:#5396B0;"}
```{r}
clim <-read.csv2("data/SPA3/stations_Tunisie.csv")
```

**DonnÃ©es OSM sur Sousse**  
DÃ©jÃ  vu dans [SPA1 : RÃ©sumÃ© d'un semis de points]{style="color:#5396B0;"}
```{r}
#| message: false
cafes <- st_read("data/SPA3/cafes_sousse.gpkg", quiet = TRUE)
secteurs <- st_read("data/SPA3/sousse_centre.gpkg", quiet = TRUE)
mer <- st_read("data/SPA3/sousse_mer.gpkg", quiet = TRUE)
```

<br>



# 1. AgrÃ©gations spatiales

Une des mÃ©thodes, simple, pour **passer des points aux surfaces** est d'**agrÃ©ger** les donnÃ©es spatialement **selon des maillages administratifs/statistiques** (comme les gouvernorats) ou selon des **mailles gÃ©omÃ©triques** (des carreaux, des rectangles ou des hexagones). Il est alors possible de calculer une densitÃ© ou un rÃ©sumÃ© statistique (moyenne, mÃ©diane, minimum...) par maille. Au-delÃ  de l'intÃ©rÃªt de la spatialisation des donnÃ©es ponctuelles, ces agrÃ©gations spatiales permettent de croiser diffÃ©rentes couches d'information (et notamment des donnÃ©es exprimÃ©es en raster) ou encore d'Ã©valuer l'effet du MAUP Modifiable Areal Unit Problem (@openshaw_taylor1979).

Pour rÃ©aliser cette premiÃ¨re mÃ©thode passant des points aux surfaces, nous partons du tableau de donnÃ©es *Tirs au but*, dÃ©crivant la localisation de presque 35 000 tirs sur un terrain de foot "modÃ¨le", pendant la saison 2023-24 (11/8/23 au 17/3/24). Les matchs ont eu lieu dans diffÃ©rents stades, de taille variable, qui sont ici schÃ©matisÃ©s par un "terrain-modÃ¨le".

Chaque tir est localisÃ© sur ce terrain-modÃ¨le par des coordonnÃ©es *x* et *y*, selon respectivement la longueur et la largeur du terrain. Les valeurs de *x* supÃ©rieures Ã  50 correspondent au camp adverse. Les donnÃ©es *x y* Ã©tant codÃ©es sur une Ã©chelle de 0 Ã  100, nous dÃ©cidons de les mettre aux dimensions d'un terrain de foot de niveau international (d'aprÃ¨s la [Loi 1 du football sur WikipÃ©dia](https://fr.wikipedia.org/wiki/Loi_1_du_football){target="_blank"}), soit 105m x 68m. 

```{r}
# CoordonnÃ©es thÃ©oriques aux dimensions 105m x 68m
tirsfoot$x2 <- tirsfoot$x * 105 / 100
tirsfoot$y2 <- tirsfoot$y * 68 /100

```

Nous reprÃ©sentons, dans un premier temps, l'ensemble des tirs, en mettant en lumiÃ¨re les tirs d'un joueur tunisien, Wahbi Khazri (en rouge) qui a maintenant raccrochÃ©, et d'un franÃ§ais, Kylian MbappÃ© (en bleu).

```{r}

# Cartographie de l'ensemble des tirs
plot(tirsfoot$x2, tirsfoot$y2, xlim = c(0,105), ylim = c(0,68), col="grey40", pch=16, cex=0.3,
     main="Localisation des tirs vers le but \n (en rouge : Wahbi Khazri ; en bleu : Kylian MbappÃ©)",
     xlab = "Longueur d'un terrain de foot modÃ¨le (en m)",
     ylab = "Largeur (en m)")

# SÃ©lection des tirs pour Khazri et MbappÃ©
Mbappe <- tirsfoot[tirsfoot$playerName == "Kylian MbappÃ©",] 
Khazri <- tirsfoot[tirsfoot$playerName == "Wahbi Khazri",]

# ajout des points des 2 joueurs sur la premiÃ¨re carte
points(Mbappe$x2, Mbappe$y2, col="blue3", pch=16, cex=0.6)
points(Khazri$x2, Khazri$y2, col="red", pch=16, cex=0.6)

```

::: {.callout-tip collapse="false"}
## Commentaire

Il apparaÃ®t nettement une zone prÃ©fÃ©rentielle pour les tirs, en toute logique devant le but adverse (Ã  droite du graphique).          
Pour autant, on ne distingue pas nettement quelle est la zone Â± 5m oÃ¹ les tirs ont Ã©tÃ© plus frÃ©quents. Kylian MbappÃ© (en bleu) a tentÃ© plus de fois des tirs au but que Wahbi Khazri, mais plus souvent devant le but (et plutÃ´t sur la gauche).         
Comment pourrait-on rÃ©sumer les rÃ©partitions des tirs des 2 joueurs ?    
[ğŸ¤”]{style="font-size:60;"} humhum... vous avez vu derniÃ¨rement une ou des mÃ©thodes qui permettent de faire cela ;-)
:::



<br>
Pour **passer des tirs ponctuels Ã  des zones** :  
**1/** on va tout d'abord crÃ©er un **maillage rÃ©gulier**, en l'occurrence ici on choisit des hexagones, Ã  partir de la fonction *`st_make_grid()`* de `sf`. 

Voici le terrain de foot modÃ¨le dÃ©coupÃ© selon des hexagones de dimension 3m :
```{r}
#| code-overflow: wrap

grille_hex <- st_make_grid(
  st_polygon(list(rbind(c(0,0), c(105,0), c(105,68), c(0,68), c(0,0)))),  # dÃ©finition de l'emprise, ici le terrain de foot modÃ¨le
  cellsize = 3,         # dimension du maillage rÃ©gulier (ici entre 2 points opposÃ©s)
  what='polygons',      # type d'implantation de la sortie (polygones, centres la grille...)
  square=FALSE)         # carreaux/rectangles avec TRUE / hexagones avec FALSE

plot(grille_hex)
```

**2/** On calcule Ã  prÃ©sent une **valeur statistique pour chaque maille** Ã  partir de la fonction *`sf::aggregate()`*, en l'occurrence ici le nombre de tirs au but dans chaque hexagone pour reprÃ©senter la carte des densitÃ©s par hexagone : 

```{r}
#| fig.width=6

# transformation du dataframe en sf
tirsfoot_sf <- st_as_sf(tirsfoot, coords = c("x2", "y2"))

# calcul du nombre par mailles
grille_hex_nbre <- aggregate(tirsfoot_sf["id"], grille_hex, FUN = length)
names(grille_hex_nbre)[1] <- "count"

# carte de la densitÃ© des tirs par hexagone
mf_map(x = grille_hex_nbre,    ## fichier de dÃ©part
       var = "count",          ## variable oÃ¹ nbre
       type = "choro",         ## le type de carte
       pal = "Greens",         ## la palette
       breaks = "jenks",       ## la mÃ©thode de discrÃ©tisation
       nbreaks = 5,            ## le nombre de classes
       leg_title = "Nombre de tirs / hexagone",  ## le titre de la lÃ©gende
       col_na = "grey90",      ## la couleur pour les valeurs manquantes
       leg_val_rnd = 0,        ## l'arrondi des valeurs de la lÃ©gende
       leg_frame = TRUE,       ## ajout d'un cadre pour la lÃ©gende + fond
       leg_pos = 'bottomleft'
) 
mf_scale(scale_units = "m", pos = 'bottomright' )
mf_credits("Source : https://github.com/hadjdeh", pos = 'rightbottom')
mf_title("D'oÃ¹ les joueurs ont tirÃ© au but lors des matchs \ndes 5 plus grandes ligues europÃ©ennes de la saison 2023-24 ?", line=3, inner = TRUE)

# on ajoute les points mÃ©dians des tirs de MbappÃ© et de Khazri 
pt_Mbappe <- st_point(c(median(Mbappe[, "x2"]), median(Mbappe[, "y2"])))  
mf_map(pt_Mbappe,
       col = "blue3",
       cex = 1.5,
       pch = 15,
       add = TRUE)
pt_Khazri <- st_point(c(median(Khazri[, "x2"]), median(Khazri[, "y2"])))  
mf_map(pt_Khazri,
       col = "red",   
       cex = 1.5,
       pch = 15,
       add = TRUE)

# Et pour aller plus loin sur la carto, avec mapsf::mf_annotation
mf_annotation(x = as.numeric(pt_Mbappe), "Mbappe", cex = 1.5, pch = 15, pos='topleft', halo = TRUE, col_arrow = "blue3", col_txt = "blue3")
mf_annotation(x = as.numeric(pt_Khazri), "Khazri", cex = 1.5, pch = 15, pos='bottomleft', halo = TRUE, col_arrow = "red", col_txt = "red")

```

On peut voir assez nettement apparaÃ®tre la zone prÃ©fÃ©rentielle pour les tirs et la rÃ©partition quasi-symÃ©trique de part et d'autre du terrain. Remarquez que les points mÃ©dians des 2 joueurs sont trÃ¨s proches.



::: {.callout-caution icon="false"}
## A vous de jouer

Pour les plus rapides et/ou pour vous entraÃ®ner, vous pouvez rÃ©aliser les mÃªmes Ã©tapes sur les Ã©quipements Ã  Sousse et comparer les diffÃ©rentes distributions spatiales. Que constatez-vous ?
:::

Cette premiÃ¨re mÃ©thode, l'**agrÃ©gation spatiale**, est une mÃ©thode relativement simple Ã  mettre en Å“uvre. Dans l'exemple des *Tirs au but* et son analyse assez sommaire, nous avons calculÃ© une densitÃ© (en l'occurrence, le nombre de tirs) par hexagone (de dimension identique ici).            
Plus gÃ©nÃ©ralement, plusieurs choix sont possibles : on peut jouer sur le **choix du rÃ©sumÃ© statistique** (nombre, mÃ©diane...), sur la **forme du maillage** (administratif ou rÃ©gulier -carreaux, rectangles ou hexagones-) et sur la **dimension** (niveau administratif, rÃ©solution de la grille).       

<br>





# 2. Lissages de phÃ©nomÃ¨nes continus

<br>  

Les agrÃ©gations peuvent Ãªtre utilisÃ©es pour des phÃ©nomÃ¨nes continus, mais elles sont d'un intÃ©rÃªt assez pauvre. Du fait du caractÃ¨re continu (Â«Â en tout point de l'espaceÂ Â»), il peut Ãªtre intÃ©ressant d'**estimer la valeur du phÃ©nomÃ¨ne justement en tout point**, seulement Ã  partir des points Ã©chantillonnÃ©s, c'est-Ã -dire d'**interpoler** les donnÃ©es. TrÃ¨s souvent, ces mÃ©thodes, appelÃ©es Â«Â **gÃ©ostatistiques**Â Â», reposent sur le principe d'**autocorrÃ©lation spatiale**. 

::: {.callout-note collapse="false"}
## AutocorrÃ©lation spatiale

L'**autocorrÃ©lation spatiale** dÃ©signe le fait que des objets proches (dans lâ€™espace) tendent Ã  possÃ©der des caractÃ©ristiques similaires. C'est un concept important en gÃ©ographie : "*(...) the first law of geography: everything is related to everything else, but near things are more related than distant things.*" (@tobler1970)

En d'autres termes, on cherche Ã  Ã©valuer si les valeurs d'une variable sont fonction de la localisation gÃ©ographique. Cela permet de dÃ©tecter la prÃ©sence dâ€™une **structure gÃ©ographique**, mais elle est aussi souvent une des premiÃ¨res Ã©tapes d'une **interpolation des donnÃ©es** (= procÃ©dure permettant dâ€™estimer la valeur dâ€™attributs pour des sites non-Ã©chantillonnÃ©s, Ã  partir de valeurs et des positions de points se situant dans une mÃªme rÃ©gion).


:::

Sous `R`, il existe plusieurs packages autour de l'interpolation des donnÃ©es, principalement dans le monde du **raster**. Dans ce module, la dÃ©monstration sera construite Ã  partir des *packages* [`gstat`](https://cran.r-project.org/web/packages/gstat/index.html){target="_blank"}^[TrÃ¨s souvent utilisÃ© par d'autres packages d'interpolation des donnÃ©es ou plus largement par des packages de manipulation des donnÃ©es spatiales, comme 
`terra`.] (assez classique en gÃ©ostatistique) et [`terra`](https://cran.r-project.org/web/packages/terra/index.html){target="_blank"}.        
La plupart des mÃ©thodes reposent sur la **construction d'un modÃ¨le** prenant en compte les mesures Ã©chantillonnÃ©es et leur localisation (distance), qu'on applique **ensuite Ã  l'ensemble de l'espace** dÃ©fini par une grille, des points de grille ou le plus souvent un raster.  

Pour plus d'informations, vous trouverez plusieurs ressources sur internet, en particulier l'ouvrage en ligne de @Pebesma_Bivand2023, et un exemple plus que classique de la pollution des sols le long d'une portion de la Meuse^[En recherchant sur un moteur de recherche, meuse + R, vous trouverez de trÃ¨s nombreux pas Ã  pas, dÃ©veloppements mÃ©thodologiques, etc. Aussi possible en mettant un autre logiciel.].


:::: {.columns}

::: {.column width="68%"}

Pour l'**exemple d'application**, nous allons reprendre le tableau des **donnÃ©es climatiques sur la Tunisie**, utilisÃ© dans [*STA3 : Statistique MultivariÃ©e*]{style="color:#5396B0;"}.   
Rappelez-vous, quelles sont les principales structures spatiales observÃ©es, en termes de tempÃ©ratures et de prÃ©cipitations (cf. carte ci-contre) ? Ces grandeurs dÃ©crivent des **phÃ©nomÃ¨nes continus dans l'espace**, i.e. tout point de l'espace peut Ãªtre caractÃ©risÃ© par une tempÃ©rature ou une quantitÃ© de prÃ©cipitation.


**PrÃ©paration des donnÃ©es :**   
**1/** Transformation du tableau de donnÃ©es climatiques sur la Tunisie en donnÃ©es spatiales [`sf`](https://cran.r-project.org/web/packages/sf/index.html){target="_blank"}, puis en *SpatVector* (le type d'objet vectoriel sous [`terra`](https://cran.r-project.org/web/packages/terra/index.html){target="_blank"}). 

```{r}
#| code-overflow: wrap

# du dataframe vers sf
clim_sf <- st_as_sf(clim, coords = c("LONGITUDE", "LATITUDE"), crs = 4326)

# projection en ETRS89-extended / LAEA Europe 
clim_sf <- st_transform(clim_sf, crs = 3035)

# crÃ©ation d'un fichier SpatVector 
clim_spatv <- vect(clim_sf)
```


:::

::: {.column width="2%"}

:::

::: {.column width="30%"}

```{r}
#| echo: false
#| fig-width: 3

mf_map(reg, col="bisque", border="white")
mf_map(x = clim_sf,       ## fichier de dÃ©part
       var = "P.mm",      ## variable PrÃ©cipitations
       type = "choro",    ## le type de carte, ici choroplÃ¨the
       pal = "Blues",     ## la palette
       breaks =  c(0, 150, 300, 450, 600, 750),  ## la mÃ©thode de discrÃ©tisation
       leg_title = "Total annuel (en mm)",  ## le titre de la lÃ©gende
       leg_val_rnd = -1,
       add = TRUE
)
mf_credits("Source : Fichier envoyÃ© par Salem Dahech, 2024")
mf_title("PrÃ©cipitations en Tunisie")
mf_scale(pos = 'bottomright')

```

:::

::::

**2/** CrÃ©ation d'un raster (ici arbitraitement de 1 km), qui sera utilisÃ©e dans plusieurs des mÃ©thodes d'interpolation :
```{r}
#| code-overflow: wrap

clim_r_1km <- rast(reg,        # en prenant, par ex, les rÃ©gions pour l'emprise spatiale
                   res=1000)   # de rÃ©solution 1000 soit 1km (dans le CRS ici)

```

::: {.callout-note collapse="true"}
## Code R mapsf pour la crÃ©ation de la carte

```{r}
#| eval: false

mf_map(reg, col="bisque", border="white")
mf_map(x = clim_sf,       ## fichier de dÃ©part
       var = "P.mm",      ## variable PrÃ©cipitations
       type = "choro",    ## le type de carte, ici choroplÃ¨the
       pal = "Blues",     ## la palette
       breaks =  c(0, 150, 300, 450, 600, 750),  ## discrÃ©tisation manuelle
       leg_title = "Total annuel (en mm)",  ## le titre de la lÃ©gende
       leg_val_rnd = 0,
       add = TRUE
)
mf_credits("Source : Fichier envoyÃ© par Salem Dahech, 2024")
mf_title("PrÃ©cipitations en Tunisie")
mf_scale(pos = 'bottomright')
```
:::

<br>



## â€¢ Polygones de Thiessen ou de VoronoÃ¯

Assez simple Ã  mettre en Å“uvre, la mÃ©thode des **polygones de Thiessen/VoronoÃ¯** estime la valeur dâ€™un point, Ã  partir de celles de ses voisins et de leur distance, en utilisant la **mÃ©thode du plus proche voisin** : la valeur de chaque cellule de la surface est Ã©gale Ã  la valeur de la donnÃ©e situÃ©e le plus prÃ¨s.  La taille et la forme des polygones ne dÃ©pendera donc que de la distribution des points dâ€™Ã©chantillonnage.   


**Elle transforme le phÃ©nomÃ¨ne continu en un modÃ¨le spatialement discret** (@caloz_collet2011) et ne prÃ©suppose pas d'Ã©tude statistique au prÃ©alable (notamment d'autocorrÃ©lation spatiale).

Vous verrez peut-Ãªtre prochainement, dans [[SPA3] ModÃ©liser des aires d'influence]{style="color:#5396B0;"}, la fonction *`sf::st_voronoi()`*, pour faire des polygones de Thiessen/VoronoÃ¯. Ici, nous proposons une autre maniÃ¨re, avec le package [`terra`](https://cran.r-project.org/web/packages/terra/index.html){target="_blank"}.


:::: {.columns}

::: {.column width="68%"}

CrÃ©ation des polygones Ã  partir des points, puis dÃ©coupage selon le contour de la Tunisie : 
```{r}
#| code-overflow: wrap
#| fig-cap: 
#|   - "CrÃ©ation des polygones"
#|   - "DÃ©coupage selon la Tunisie"
#| fig-align: left
#| layout-ncol: 2
#| layout-valign: top

# crÃ©ation polygones de VoronoÃ¯/Thiessen
poly_voronoi <- voronoi(clim_spatv)
plot(poly_voronoi)
points(clim_spatv, col = "seagreen")

# fusion des rÃ©gions et format SpatVector
contour_tunisie <- vect(st_union(reg))  

# dÃ©coupage des polygones selon le contour 
poly_voronoi <- crop(poly_voronoi, contour_tunisie)
plot(poly_voronoi)
points(clim_spatv, col = "seagreen")

```

:::

::: {.column width="2%"}

:::

::: {.column width="30%"}


```{r}
#| echo: false
#| fig-width: 3

# mapsf ne lit pas (encore ?) les objets SpatVect, alors transformation 
poly_voronoi_sf <- st_as_sf(poly_voronoi) 

mf_map(x = poly_voronoi_sf,   ## fichier de dÃ©part
       var = "P.mm",          ## variable PrÃ©cipitations
       type = "choro",        ## le type de carte, ici choroplÃ¨the
       pal = "Blues",         ## la palette
       breaks =  c(0, 150, 300, 450, 600, 750),  ## discrÃ©tisation manuelle
       leg_title = "Total annuel (en mm)",  ## le titre de la lÃ©gende
       leg_pos = 'topleft',
       leg_val_rnd = 0,
)
mf_title("PrÃ©cipitations - polygones de VoronoÃ¯")
mf_credits("Source : Fichier envoyÃ© par Salem Dahech, 2024")
mf_map(clim_sf, col = "seagreen", cex = 2, add = TRUE)
mf_scale(pos = 'bottomright')

```
:::

::::


::: {.callout-note collapse="true"}
## Code R mapsf pour la crÃ©ation de la carte
```{r}
#| eval: false

# mapsf ne lit pas (encore ?) les objets SpatVect, alors transformation 
poly_voronoi_sf <- st_as_sf(poly_voronoi) 

mf_map(x = poly_voronoi_sf,   ## fichier de dÃ©part
       var = "P.mm",          ## variable PrÃ©cipitations
       type = "choro",        ## le type de carte, ici choroplÃ¨the
       pal = "Blues",         ## la palette
       breaks =  c(0, 150, 300, 450, 600, 750),  ## discrÃ©tisation manuelle
       leg_title = "Total annuel (en mm)",  ## le titre de la lÃ©gende
       leg_pos = 'topleft',
       leg_val_rnd = 0,
)
mf_title("PrÃ©cipitations - polygones de VoronoÃ¯")
mf_credits("Source : Fichier envoyÃ© par Salem Dahech, 2024")
mf_scale(pos = 'bottomright')
mf_map(clim_sf, col = "seagreen", cex = 2, add = TRUE) # ajout des points des stations

```

:::

<br>

## â€¢ Inverse de la distance pondÃ©rÃ©e (IDW)


La mÃ©thode IDW (*inverse distance weighting*), assez classique Ã©galement, repose sur le calcul de **moyennes mobiles pondÃ©rÃ©es par lâ€™inverse de la distance Ã©levÃ©e Ã  une puissance**. Ã€ partir d'une grille rÃ©guliÃ¨re ou d'un raster, on rÃ©alise pour chaque cellule : 

- SÃ©lection des *n* plus proches voisins ou selon un voisinage d'une certaine portÃ©e,

- Calcul de la moyenne de leurs attributs en pondÃ©rant par lâ€™inverse de la distance Ã©levÃ©e Ã  une puissance (souvent 2).

On peut donc ajuster la mÃ©thode en choisissant les voisins retenus (câ€™est-Ã -dire le Â«Â **rayon dâ€™influence**Â Â») et aussi la **puissance** (lorsque celle-ci tend vers 1, la dÃ©croissance de lâ€™influence dâ€™un point tend vers une fonction linÃ©aire ; plus elle est Ã©levÃ©e, plus la dÃ©croissance augmente rapidement ; Ã©gale Ã  0, elle correspond Ã  la triangulation de Delaunay et Ã  une absence de l'effet de la distance).

Sous `R`, nous allons utiliser la fonction gÃ©nÃ©rique de gÃ©ostatistique *`gtat()`* du package [`gstat`](https://cran.r-project.org/web/packages/gstat/index.html){target="_blank"} qui permet de choisir une mÃ©thode d'interpolation (ici en prÃ©cisant *nmax* et *idp*, on indiquera IDW, le nombre de points et la puissance). On le fait sur un tableau de donnÃ©es avec des colonnes "x" et "y" (<span style="color:#cd0000;">attention : le non respect du libellÃ© des colonnes peut conduire Ã  des galÃ¨res...</span>). 

:::: {.columns}

::: {.column width="68%"}

```{r}
#| eval: false
#| code-overflow: wrap

# retour Ã  un dataframe avec 2 colonnes x et y
clim_df <- data.frame(geom(clim_spatv)[, c("x", "y")], as.data.frame(clim_spatv))

# construction d'un modÃ¨le 
model_gs <- gstat(data = clim_df,     
                  locations=~x+y, 
                  id = "P.mm", 
                  formula = P.mm ~ 1, 
# 1~ pour ne pas prendre de co-variables ici (comme l'altitude, etc.) 
                  nmax=7, 
                  set=list(idp = 2))

# application du modÃ¨le Ã  l'ensemble de l'emprise spatiale
idw <- interpolate(clim_r_1km, model_gs, debug.level=0)
# l'option debug.level=0 permet de pas afficher ici les messages, i.e. le modÃ¨le retenu "[inverse distance weighted interpolation]"

# dÃ©coupage du rÃ©sultat selon le contour 
idw_tun <- mask(idw, reg)

# cartographie
# du raster
mf_raster(idw_tun$P.mm.pred,
          pal = "Blues", 
          type = "interval",
          breaks =  seq(0, 750, 10),  
)
# ajout des stations
mf_map(clim_sf, col = "seagreen", cex = 2, add = TRUE)
# ajout des graticules (latitudes et longitudes)
mf_graticule(reg, lwd=0.5, cex = .6)
# ajout d'un contour
mf_map(st_union(reg), border = "grey40", col=NA, add=TRUE)
# ajout de la source
mf_credits("Source : Fichier envoyÃ© par Salem Dahech, 2024")
# ajout de l'Ã©chelle
mf_scale(pos = 'bottomright')
# ajout du N
mf_arrow()
# ajout du titre
mf_title("IDW (puissance : 2)")



```


:::

::: {.column width="2%"}

:::

::: {.column width="30%"}


**Carte des prÃ©cipitations selon la mÃ©thode IDW**

```{r}
#| echo: false
#| fig-width: 3
#| warning: false

# rÃ©-exÃ©cution du code, sinon blocage
clim_df <- data.frame(geom(clim_spatv)[, c("x", "y")], as.data.frame(clim_spatv))
model_gs <- gstat(data = clim_df,     
                  locations=~x+y, 
                  id = "P.mm", 
                  formula = P.mm ~ 1, 
                  nmax=7, 
                  set=list(idp = 2))
idw <- interpolate(clim_r_1km, model_gs, debug.level=0)
idw_tun <- mask(idw, reg)

mf_raster(idw_tun$P.mm.pred,
          pal = "Blues", 
          type = "interval",
          breaks =  seq(0, 750, 10),
          leg_pos = NA
)
# ajout des stations
mf_map(clim_sf, col = "seagreen", cex = 2, add = TRUE)
# ajout des graticules (latitudes et longitudes)
mf_graticule(reg, lwd=0.5, cex = .6)
# ajout d'un contour
mf_map(st_union(reg), border = "grey40", col=NA, add=TRUE)
# ajout de la source
mf_credits("Source : Fichier envoyÃ© par Salem Dahech, 2024")
# ajout de l'Ã©chelle
mf_scale(pos = 'bottomright')
# ajout du N
mf_arrow()
# ajout du titre
mf_title("IDW (puissance : 2)")



```

![](img/Leg_Preci.png)

:::

::::

::: {.callout-note collapse="true"}
## Autre procÃ©dure un peu plus rapide qui utilise le package [`terra`](https://cran.r-project.org/web/packages/terra/index.html){target="_blank"}

```{r}
#| layout-ncol: 3
#| code-overflow: wrap
#| fig-width: 3
#| eval: false

idw_terra <- interpIDW(clim_r_1km, clim_spatv, field = "P.mm", radius=500000, power=2, maxPoints=7)
idw_terra_tun <- mask(idw_terra, reg)

mf_raster(idw_terra_tun,
          pal = "Blues", 
          type = "interval",
          breaks =  seq(0, 750, 10),  
          leg_pos = NA
)
mf_map(clim_sf, col = "seagreen", cex = 2, add = TRUE)
mf_title("IDW, p=2, 7 pts, p=500km")
# ajout des graticules (latitudes et longitudes)
mf_graticule(reg, lwd=0.5, cex = .6)
# ajout d'un contour
mf_map(st_union(reg), border = "grey40", col=NA, add=TRUE)
# ajout de la source
mf_credits("Source : Fichier envoyÃ© par Salem Dahech, 2024")
# ajout du N
mf_arrow()
# ajout de l'Ã©chelle
mf_scale(pos = 'bottomright')


```
:::

En faisant varier les paramÃ¨tres de la mÃ©thode : 
```{r}
#| layout-ncol: 3
#| code-overflow: wrap
#| fig-width: 3
#| echo: false

idw_terra <- interpIDW(clim_r_1km, clim_spatv, field = "P.mm", radius=500000, power=2, maxPoints=7)
idw_terra_tun <- mask(idw_terra, reg)

idw_terra_bis <- interpIDW(clim_r_1km, clim_spatv, field = "P.mm", radius=500000, power=1, maxPoints=7)

idw_terra_ter <- interpIDW(clim_r_1km, clim_spatv, field = "P.mm", radius=500000, power=4, maxPoints=7)

mf_raster(idw_terra_tun,
          pal = "Blues", 
          type = "interval",
          breaks =  seq(0, 750, 10),  
          leg_pos = NA
)
mf_map(clim_sf, col = "seagreen", cex = 2, add = TRUE)
mf_title("IDW, p=2, 7 pts, p=500km")
# ajout des graticules (latitudes et longitudes)
mf_graticule(reg, lwd=0.5, cex = .6)
# ajout d'un contour
mf_map(st_union(reg), border = "grey40", col=NA, add=TRUE)
# ajout de la source
mf_credits("Source : Fichier envoyÃ© par Salem Dahech, 2024")
# ajout du N
mf_arrow()



mf_raster(mask(idw_terra_bis, reg),
          pal = "Blues", 
          type = "interval",
          breaks =  seq(0, 750, 10), 
          leg_pos = NA
)
mf_map(clim_sf, col = "seagreen", cex = 2, add = TRUE)
mf_title("IDW, p=1, 7 pts, p=500km")
mf_graticule(reg, lwd=0.5, cex = .6)
# ajout d'un contour
mf_map(st_union(reg), border = "grey40", col=NA, add=TRUE)


mf_raster(mask(idw_terra_ter, reg),
          pal = "Blues", 
          type = "interval",
          breaks =  seq(0, 750, 10),  
          leg_pos = NA
)
mf_map(clim_sf, col = "seagreen", cex = 2, add = TRUE)
mf_title("IDW, p=4, 7 pts, p=500km")
# ajout de l'Ã©chelle
mf_scale(pos = 'bottomright')
mf_graticule(reg, lwd=0.5, cex = .6)
# ajout d'un contour
mf_map(st_union(reg), border = "grey40", col=NA, add=TRUE)



```

![](img/Leg_Preci.png){width=40% fig-align="center"}

::: {.callout-tip collapse="false"}
## Commentaire

Les nuances sur ces 3 cartes avec des paramÃ¨tres diffÃ©rents sont assez subtiles, Ã  cette Ã©chelle et avec la palette choisie. En choisissant exprÃ¨s une palette divergente, on peut remarquer une importance plus Â«Â diluÃ©eÂ Â» des valeurs des stations pour la puissance 1 Ã  l'inverse de p = 4.
```{r}
#| layout-ncol: 3
#| code-overflow: wrap
#| fig-width: 3
#| echo: false

mf_raster(idw_terra_tun,
          pal = "PRGn", 
          type = "interval",
          breaks =  seq(0, 750, 10),  
          leg_pos = NA
)
mf_map(clim_sf, col = "grey30", cex = 1, add = TRUE)
mf_title("IDW, p=2, 7 pts, p=500km")


mf_raster(mask(idw_terra_bis, reg),
          pal = "PRGn", 
          type = "interval",
          breaks =  seq(0, 750, 10), 
          leg_pos = NA
)
mf_map(clim_sf, col = "grey30", cex = 1, add = TRUE)
mf_title("IDW, p=1, 7 pts, p=500km")

mf_raster(mask(idw_terra_ter, reg),
          pal = "PRGn", 
          type = "interval",
          breaks =  seq(0, 750, 10),  
          leg_pos = NA
)
mf_map(clim_sf, col = "grey30", cex = 1, add = TRUE)
mf_title("IDW, p=4, 7 pts, p=500km")


```
:::


<br>

## â€¢ Surfaces de tendance

Lâ€™objectif de cette mÃ©thode est dâ€™approcher la surface, dÃ©terminÃ©e Ã  partir des points de mesure, par une **surface polynomiale** pouvant Ãªtre **de plusieurs ordres**. Le choix d'un ordre 1, soit une Â«Â surface de tendance du premier degrÃ©Â Â», rend compte d'un gradient spatial linÃ©aire (de type Z = a + bX + cY), par ex un gradient SW-NE. Plus on augmente l'ordre, plus on prend en compte les effets plus locaux, mais on s'Ã©carte alors du pouvoir explicatif de la variabilitÃ© spatiale Ã  large Ã©chelle et il peut s'avÃ©rer difficile d'interprÃ©ter le rÃ©sultat de la modÃ©lisation. 

:::: {.columns}

::: {.column width="68%"}

Sous `R`, toujours avec la fonction gÃ©nÃ©rique *`gstat()`* et en prÃ©cisant le degrÃ© ou l'ordre de la surface de tendance (*degree =*) :

```{r}
#| eval: false
model_gs1 <- gstat(data = clim_df,     
                  locations=~x+y, 
                  id = "P.mm", 
                  formula = P.mm ~ 1, 
                  degree = 1)
surftend_1 <- interpolate(clim_r_1km, model_gs1, debug.level=0)
surftend_1_tun <- mask(surftend_1, reg)
plot(surftend_1_tun$P.mm.pred)
```

Les totaux annuels de prÃ©cipitations diminuent du nord au sud de la Tunisie, jusqu'Ã  atteindre des valeurs nÃ©gatives, ce qui est impossible ! Cela est notamment liÃ© Ã  la quasi-absence de stations dans le sud de la Tunisie et Ã  un effet qu'on appelle Â«Â effet de bordÂ Â». Plus gÃ©nÃ©ralement, cela montre bien la prudence Ã  avoir, en gÃ©nÃ©ral, sur les rÃ©sultats des interpolations (spatiales ou non). 

:::

::: {.column width="2%"}

:::

::: {.column width="30%"}

```{r}
#| echo: false
#| fig-width: 3

model_gs1 <- gstat(data = clim_df,     
                  locations=~x+y, 
                  id = "P.mm", 
                  formula = P.mm ~ 1, 
                  degree = 1)
surftend_1 <- interpolate(clim_r_1km, model_gs1, debug.level=0)
surftend_1_tun <- mask(surftend_1, reg)
plot(surftend_1_tun$P.mm.pred)
```

:::

::::

En faisant varier l'ordre et en choisissant une discrÃ©tisation identique (excluant les valeurs infÃ©rieures Ã  0) : 

```{r}
#| layout-ncol: 3
#| fig-width: 3

# Surface de tendance d'ordre 2
model_gs2 <- gstat(data = clim_df,     
                  locations=~x+y, 
                  id = "P.mm", 
                  formula = P.mm ~ 1, 
                  degree = 2)
surftend_2 <- interpolate(clim_r_1km, model_gs2, debug.level=0)
surftend_2_tun <- mask(surftend_2, reg)

# Surface de tendance d'ordre 3
model_gs3 <- gstat(data = clim_df,     
                  locations=~x+y, 
                  id = "P.mm", 
                  formula = P.mm ~ 1, 
                  degree = 3)
surftend_3 <- interpolate(clim_r_1km, model_gs3, debug.level=0)
surftend_3_tun <- mask(surftend_3, reg)

surftend_1_tun$P.mm.pred[surftend_1_tun$P.mm.pred < 0,] <- NA
surftend_2_tun$P.mm.pred[surftend_2_tun$P.mm.pred < 0,] <- NA
surftend_3_tun$P.mm.pred[surftend_3_tun$P.mm.pred < 0,] <- NA

mf_map(st_union(reg), col="grey90")
mf_raster(surftend_1_tun$P.mm.pred,
          pal = "Blues", 
          type = "interval",
          breaks =  seq(0, 750, 10),  
          leg_pos = NA,
          add=TRUE
)
mf_map(st_union(reg), border = "grey40", col=NA, add=TRUE)
mf_title("Surf Tend ordre = 1")
mf_graticule(reg, lwd=0.5, cex = .6)
mf_credits("Source : Fichier envoyÃ© par Salem Dahech, 2024")
mf_arrow()

mf_map(st_union(reg), col="grey90")
mf_raster(surftend_2_tun$P.mm.pred,
          pal = "Blues", 
          type = "interval",
          breaks =  seq(0, 750, 10),  
          leg_pos = NA,
          add=TRUE
)
mf_map(st_union(reg), border = "grey40", col=NA, add=TRUE)
mf_title("Surf Tend ordre = 2")
mf_graticule(reg, lwd=0.5, cex = .6)
mf_map(st_union(reg), border = "grey40", col=NA, add=TRUE)

mf_map(st_union(reg), col="grey90")
mf_raster(surftend_3_tun$P.mm.pred,
          pal = "Blues", 
          type = "interval",
          breaks =  seq(0, 750, 10),  
          leg_pos = NA,
          add=TRUE
)
mf_map(st_union(reg), border = "grey40", col=NA, add=TRUE)
mf_title("Surf Tend ordre = 3")
mf_graticule(reg, lwd=0.5, cex = .6)
mf_map(st_union(reg), border = "grey40", col=NA, add=TRUE)
mf_scale(pos = 'bottomright')


```
![](img/Leg_Preci.png){width=40% fig-align="center"}


::: {.callout-tip collapse="true"}
## Quelques remarques

D'un point de vue pÃ©dagogique, nous avons voulu distinguer sur les cartes les valeurs nÃ©gatives. Mais nous aurions pu dÃ©cider de les mettre Ã  0 mm/an.   
Les faibles diffÃ©rences entre les 3 ordres ne sont pas liÃ©es qu'Ã  la palette utilisÃ©e ! Elles montrent ici l'importance du gradient N-S.   
   
Les **surfaces de tendance** sont des modÃ¨les statistiques (comme la rÃ©gression), il est donc possible de calculer leur **pouvoir explicatif** et d'analyser les **Ã©carts au modÃ¨le**, i.e. les rÃ©sidus.  
Les surfaces de tendance sont pertinentes lorsqu'on observe un gradient dans les donnÃ©es, c'est beaucoup moins le cas avec de nombreuses variations locales. En climatologie, elles sont parfois utilisÃ©es pour dÃ©gager les grandes structures climatiques (variation zonale = en fonction de la latitude ; continentalitÃ© ; gradient altitudinal), pour ensuite spatialiser plus finement les variations spatiales.  

:::

::: {.callout-caution icon="false"}
## A vous de jouer

Pour les plus rapides et/ou pour s'entraÃ®ner, rÃ©alisez une ou plusieurs cartes d'interpolation des tempÃ©ratures minimales et maximales.
:::

<br>

## â€¢ De l'analyse variographique Ã  l'interpolation par krigeage

Une autre famille de mÃ©thodes ne reposent pas sur une approche dÃ©terministe comme prÃ©cÃ©demment, ce sont les mÃ©thodes autour du krigeage, dÃ©veloppÃ©es par @matheron1970. Plusieurs auteurs prÃ©fÃ¨rent d'ailleurs rÃ©server le terme de Â«Â mÃ©thodes gÃ©ostatistiquesÂ Â» pour celles-ci.  

Elles reposent sur 2 Ã©tapes :

â€¢ la caractÃ©risation de la structure spatiale ou **analyse variographique**

â€¢ puis l'estimation spatiale ou **krigeage**.
 
Ã€ nouveau, plusieurs packages sous `R` permettent de rÃ©aliser ces mÃ©thodes. On citera en particulier le package [`gstat`](https://cran.r-project.org/web/packages/gstat/index.html){target="_blank"},  [`terra`](https://cran.r-project.org/web/packages/terra/index.html){target="_blank"} et [`automap`](https://cran.r-project.org/web/packages/automap/index.html){target="_blank"}. Ce dernier permet, comme son nom peut l'Ã©voquer, d'automatiser l'ensemble des Ã©tapes. 

Nous montrons ici les Ã©tapes Ã  partir des donnÃ©es de prÃ©cipitations, mÃªme si le nombre de stations est trop faible. De plus, la structure spatiale ici Â«Â se limiteÂ Â» Ã  un gradient, ce qui limite l'intÃ©rÃªt du krigeage.

### Analyse variographique

La premiÃ¨re Ã©tape repose sur la **construction d'un semi-variogramme empirique**, permettant dâ€™estimer **comment la Â«Â dÃ©pendanceÂ Â» spatiale varie avec la distance**. 

La fonction *`gstat::variogram()`* calcule les valeurs du semi-variogramme : 
```{r}
# Semi-variogramme expÃ©rimental / empirique
Vario <- variogram(P.mm~1, data=clim_sf)
# 1~ pour ne pas prendre de co-variables ici (comme l'altitude, etc.) 
      
head(Vario) 
```
np : nombre de paires, dist : distance, gamma : la valeur de semi-variance 

```{r}
plot(Vario, 
     plot.numbers = TRUE) # pour ajouter le nombre de paires pour chaque point
```

Le choix du pas influence lâ€™allure du variogramme. Il doit, au moins, Ãªtre infÃ©rieur Ã  la moitiÃ© de la plus grande distance entre les points de mesure utilisÃ©s (@Journel_Huijbregts1976). Il est possible de le prÃ©ciser dans la fonction *`variogram()`* avec *`width =`*, ou d'utiliser la distance par dÃ©faut.

La lecture d'un variogramme :

- le **palier et sa portÃ©e** (qui montre la limite de l'influence spatiale d'un point sur ces voisins) ; 

- le **comportement avant le palier** (variation linÃ©raire, exponentielle...) ; 

- l'importance de l'**effet pÃ©pite** Ã  proximitÃ© de l'origine (qui tÃ©moigne des variations locales) ; 

- et enfin le **comportement directionnel** (anisotropie).


Ici, dans l'exemple des prÃ©cipitations en Tunisie, on n'observe pas de palier mais une augmentation assez continue des valeurs de semivariance avec la distance, qui tÃ©moigne d'un gradient.

L'analyse directionnelle ne donne pas de rÃ©sultats plus probants. Le gradient s'observe trÃ¨s nettement selon la direction 0Â°, soit du N au S (sans surprise !), et dans une moindre mesure selon 135Â° (SE-NW).        
Rappelons que le nombre de points ici reste faible pour ce type d'analyse.

```{r}

# selon les directions
vario_directionnel <- variogram(P.mm~1, data=clim_sf,
                                alpha = c(0, 45, 90, 135)) # soit N-S, NE-SW, E-W, SE-NW
plot(vario_directionnel)

```

Pour trouver ensuite l'ajustement, on peut le faire automatiquement ou contraindre un ajustement selon un certain modÃ¨le. Ici, pour l'exemple, nous montrons, sans commenter les rÃ©sultats, la procÃ©dure R pour un ajustement sphÃ©rique (qui ne se justifie pas Ã  la lecture du variogramme). 

```{r}
## Ajustement du semi-variogramme 
Vario.fit <- fit.variogram(Vario, vgm("Sph")) # ModÃ¨le d'ajustement (ici sphÃ©rique) 
Vario.fit
# Nug / psill >= effet pÃ©pite

```

<br>

### Le krigeage

AprÃ¨s la lecture du variogramme puis la sÃ©lection d'un modÃ¨le d'ajustement, on applique l'interpolation Ã  l'ensemble de la zone d'Ã©tude, c'est ce qu'on appelle le Â«Â **krigeage**Â Â». Il fait rÃ©fÃ©rence Ã  une famille de mÃ©thodes (krigeage simple, ordinaire, universel, co-krigeage...). Pour cela et comme dÃ©jÃ  vu, auparavant, on va crÃ©er une grille...

```{r}

# crÃ©ation d'une grille (en points) 
clim.grid <- st_make_grid(reg, what = "centers", cellsize = 1000)
# Limit
clim.grid <- st_intersection(clim.grid, reg)

# Krigeage : resultat <- krige(Z_pour_data ~ 1, tabdata_depart, grille, model = modÃ¨le_Ã©tape_prÃ©cÃ©dente)
krigeage <- krige(P.mm~1, clim_sf, clim.grid, model=Vario.fit) 
plot(krigeage)

```

Un krigeage produit 2 champs comme rÃ©sultats : les valeurs estimÃ©es (*.pred*) et la qualitÃ© de l'ajustement (*.var*). 

La sortie d'un krigeage *via* *`gstat`* est un `sf` de points, qu'on peut traiter, cartographier, etc : 
```{r}
head(krigeage)
```



### Avec *`automap`*

Attention : `automap` utilise des objets spatiaux *`sp`* et non *`sf`*. La fonction *`as_Spatial()`* permet de transformer le type d'objet.

```{r}
AutoKrigeage <- autoKrige(formula = P.mm ~ 1,
                          input_data = as_Spatial(clim_sf), 
                          new_data = as_Spatial(clim.grid))
head(AutoKrigeage[[1]])
plot(AutoKrigeage)
```

::: {.callout-tip collapse="false"}
## Commentaire

Les cartes des krigeages montrent bien le gradient N-S, Ã  nouveau, avec une confiance dans l'estimation des valeurs qui diminuent inversement, ce qui s'explique par la localisation des stations mÃ©tÃ©orologiques.

:::

::: {.callout-caution icon="false"}
## A vous de jouer

Pour les plus rapides et/ou pour vous entraÃ®ner, vous pouvez rÃ©aliser les mÃªmes Ã©tapes Ã  partir des mesures de tempÃ©rature rÃ©alisÃ©es par Sami Charfi et Salem Dahech. Cette fois-ci, il y a beaucoup plus de points, le poids statistique est renforcÃ©. Par contre, les mesures rÃ©alisÃ©es sur des transects limitent la validitÃ© spatiale des valeurs estimÃ©es.   
Alors, observe-t-on un Ã®lot de chaleur urbain ?
:::

<br>


# 3. Lissages de phÃ©nomÃ¨nes discrets 

<br>  

Deux mÃ©thodes principales pour reprÃ©senter de maniÃ¨re continue des donnÃ©es discrÃ¨tes :

- Le **lissage par potentiel**, pour reprÃ©senter une quantitÃ© de Â«Â ressourcesÂ Â» (populations, richesses...) prÃ©sentes dans un voisinage donnÃ©e autour de ce lieu.
- Le **lissage par noyaux (kernels)**, pour reprÃ©senter la prÃ©sence/absence dâ€™un phÃ©nomÃ¨ne dans un voisinage, identifier les zones de forte concentration du phÃ©nomÃ¨ne. C'est cette deuxiÃ¨me mÃ©thode qui sera dÃ©veloppÃ©e ici.


## â€¢ Lissage par noyaux de densitÃ© (Kernel Density Estimation)

**Principe gÃ©nÃ©ral** :

La mÃ©thode des noyaux de densitÃ©, dite aussi mÃ©thode KDE (Kernels Density Estimation), repose sur un principe commun Ã  lâ€™ensemble des cartes lissÃ©es : la prise en compte du **voisinage des lieux** observÃ©s. La prÃ©sence dâ€™un phÃ©nomÃ¨ne en un point i de lâ€™espace Ã©tant supposÃ©e indissociable de celle de ses voisins, la densitÃ© du phÃ©nomÃ¨ne dans le voisinage de i peut Ãªtre estimÃ©e par la **quantitÃ© dâ€™observations qui se trouvent Ã  proximitÃ© de i, rapportÃ©e Ã  la surface de ce voisinage**. Chaque lieu est ainsi dÃ©crit non pas par lâ€™absence/prÃ©sence dâ€™un phÃ©nomÃ¨ne mais par lâ€™intensitÃ© (=la densitÃ©) du phÃ©nomÃ¨ne observÃ© dans le voisinage de ce lieu. 

Cette mÃ©thode permet ainsi de faire apparaÃ®tre des **continuitÃ©s de tendance dans lâ€™espace**. A l'Å“il nu, ces concentrations ne sont pas toujours lisibles sur les cartes de semis de points, en raison de la frÃ©quente surcharge d'information. La mÃ©thode de lissage par noyaux permet de transformer cette information ponctuelle discrÃ¨te (absence/prÃ©sence d'un phÃ©nomÃ¨ne) en une **surface de densitÃ©** qui reprÃ©sente l'intensitÃ© du phÃ©nomÃ¨ne Ã©tudiÃ© en tout point de l'espace.


**ProcÃ©dure** :

::: {layout="[30,70]"}
::: {first-column}
(1) CrÃ©ation dâ€™une grille dâ€™estimation, maillant lâ€™espace Ã©tudiÃ© 
(2) Sur le centre de chaque carreau de la grille (point dâ€™estimation des densitÃ©s), on place une Â« boÃ®te Â» en forme de cloche au sein de laquelle on compte le nombre de points observÃ©s dans le voisinage du point dâ€™estimation. 
Cette Â« boÃ®te Â» est dÃ©finie par deux paramÃ¨tres :
              Sa portÃ©e (notÃ©e h sur le schÃ©ma)
              Sa forme (notÃ©e K sur le schÃ©ma). Le fait quâ€™il sâ€™agisse ici dâ€™une forme en Â« cloche Â» signifie que lâ€™on souhaite donner un poids plus important aux observations proches du point dâ€™estimation et un poids nÃ©gligeable aux observations les plus Ã©loignÃ©es. Il sâ€™agit le plus souvent (comme ici) dâ€™une fonction dÃ©croissante de la distance de type gaussien.
(3) Par itÃ©ration, on fait glisser cette boÃ®te dâ€™un carreau Ã  lâ€™autre de la grille dâ€™estimation = on crÃ©e autrement dit une fenÃªtre mobile qui balaie la zone Ã©tudiÃ©e pour attribuer Ã  chaque carreau une valeur de densitÃ© dâ€™un phÃ©nomÃ¨ne dans un voisinage de portÃ©e h.
- Parfois, une derniÃ¨re Ã©tape, non reprÃ©sentÃ©e sur le schÃ©ma, consiste Ã  appliquer une fonction de lissage graphique Ã  la grille, pour gommer les discontinuitÃ©s liÃ©es aux limites des carreaux.
::: 
::: {second-column}
![](img/KernelsSchema.png)
::: 
:::

Le choix de la fonction de lissage dÃ©pend donc de deux paramÃ¨tres principaux :

- La **portÃ©e (le rayon) de la fenÃªtre de voisinage**, sur laquelle on peut jouer pour faire ressortir des structures dâ€™organisation plus ou moins Ã©lÃ©mentaires ou dÃ©taillÃ©es.

- La **forme de cette fenÃªtre**, dÃ©terminÃ©e par la fonction de pondÃ©ration des observations autour du point dâ€™estimation : aux deux extrÃªmes, la fonction uniforme (moyenne de toutes les observations du voisinage, sans pondÃ©ration) est plus simple Ã  comprendre mais introduit des discontinuitÃ©s visuelles non nÃ©gligeables, tandis que la fonction gaussienne est une de celles qui traduit le mieux les continuitÃ©s de tendances dans lâ€™espace. 

<br>

**Dans R, avec Spatstats** :

Application aux **cafÃ©s du centre de Sousse**


**Conversion** des donnÃ©es de points dans le **format ppp** adaptÃ© Ã  spatstat
```{r}
# RÃ©cupÃ©ration des coordonnÃ©es X,Y pour les cafes de Sousse
# Puis crÃ©ation d'un objet points en format adaptÃ© Ã  spatstat (.ppp)
pts <- st_drop_geometry(cafes[,c("X","Y")])
bbox <- st_bbox(secteurs)
bbox
p <- ppp(pts[,1], pts[,2], window=owin(c(bbox$xmin,bbox$xmax), c(bbox$ymin,bbox$ymax)))
```

**Carte brute de densitÃ© par noyaux**
Cette carte est rÃ©alisÃ©e Ã  partir de la fonction *density.ppp* de *spatstat*.
```{r}
# sigma = portÃ©e de la fenÃªtre (ici, 500 mÃ¨tres)
# kernel = fonction de dÃ©croissance de la distance. Par dÃ©faut, fonction gaussienne. 
# Autres fonctions courantes : "epanechnikov", "quartic", "disc".

ds <- density.ppp(p, kernel="epanechnikov",sigma = 500)
rasdens <- rast(ds)

# Et pour convertir la lÃ©gende en densitÃ© au kmÂ² ...
# (par dÃ©faut : dans les unitÃ©s de la projection, en mÂ²)
rasdens <- rast(ds) * 1000 * 1000
rasdens <- rasdens
plot(rasdens)
```


**Carte "habillÃ©e" de la densitÃ© par noyaux**
```{r, fig.height=6, fig.width=6}

par(mar = c(0.5,0.5,1.2,0.5))

bks <- getBreaks(values(rasdens), nclass = 12, method = "equal")
cols <- colorRampPalette((c("white","tomato","darkorchid4")))(length(bks)-1)
plot(rasdens, breaks= bks, col=cols,legend=F)

legendChoro(pos = "topleft",cex = 0.7, title.cex = 0.7,
            title.txt = "DensitÃ© de cafÃ©s\nKDE (epanechnikov\n,sigma=500m\n(cafÃ©s par km2))",
            breaks = bks-1, nodata = FALSE,values.rnd = 1, col = cols)

plot(st_geometry(secteurs), border = "grey50",col=NA,lwd = 0.1,add=T)
plot(st_geometry(cafes), col = "blue", pch = 20, cex = 0.5, add=T)
plot(st_geometry(mer), col="lightblue1",border = "grey60",add=T)

layoutLayer(title = "DensitÃ© de cafÃ©s Ã  Sousse", scale = 1,
            tabtitle = TRUE, frame = FALSE,
            sources = "OpenStreetMap 2024, INS")

```

::: {.callout-caution icon="false"}
## A vous de jouer

Testez diffÃ©rentes valeurs de portÃ©e du lissage Ã  l'aide de l'argument **sigma =** de la fonction **density.ppp** (par exemple pour un voisinage de 300m ou 500m) et de diffÃ©rentes fonctions de dÃ©croissance de la distance Ã  l'aide de l'argument **kernel =** de la fonction **density.ppp**.   
- Quelles logiques de concentration des cafÃ©s semblent Ã©merger sur ces cartes ?
:::


#### **Pour aller plus loin...**

â€¢ Sur les noyaux de densitÃ© (KDE), voir par exemple :\

-   Un site de ressources sur *spatstat*, par les crÃ©ateurs du package, A. Baddeley, R. Turner et E. Rubak, [ici](https://spatstat.org/resources.html){target="_blank"}.

-   Plusieurs exemples de cartes lissÃ©es par noyaux de densitÃ© sous `R`, appliquÃ©es aux bars et diffÃ©rents types de restaurants parisiens [Giraud, 2017](https://rcarto.github.io/caRtosm/index.html){target="_blank"}, ou encore aux hÃ´pitaux pÃ©diatriques de Singapour [Tin Seong, 2019](https://rpubs.com/tskam/IS415-Hands-on_Ex04){target="_blank"}

-   Pour aller beaucoup plus loin : un chapitre du manuel de l'INSEE d'analyse spatiale avec R sur les cartes de densitÃ© par noyaux [(chapitre 8)](https://www.insee.fr/fr/statistiques/fichier/3635442/imet131-l-chapitre-8.pdf){target="_blank"}.

â€¢ Sur les lissages par potentiel\

- voir le site web du package [**`potential`**](https://riatelab.github.io/potential/articles/potential.html){target="_blank"} rÃ©alisÃ© par TimothÃ©e Giraud : exemples sur le lissage par potentiels des populations en Europe, le lissage par potentiels du revenu par habitant en Italie.


------------------------------------------------------------------------

::: {.callout-note title="A propos de ce document"}
Ce support a Ã©tÃ© crÃ©Ã© pour la semaine de formation franco-tunisienne
**GEO UNIV'R Tunisie 2024 - "Enseigner la statistique, la cartographie
et l'analyse spatiale avec R** qui se tient Ã  Sousse en mai 2024.
:::

#### RÃ©fÃ©rences {.unnumbered}

::: {#refs}
:::

------------------------------------------------------------------------

```{r sessionInfo}
sessionInfo()
```
:::