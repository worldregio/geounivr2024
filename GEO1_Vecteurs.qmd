---
title: "[GEO1] Manipuler les vecteurs avec `R` et le package `sf`"
subtitle: "GEO UNIV'R Tunisie 2024"
date: "`r Sys.Date()`"
author: "Elina Marveaux, Nicolas Lambert, Ronan Ysebaert"
format:
  html:
    embed-resources: true
    theme: yeti
    smooth-scroll: true
    fontsize: 0.9em
    toc: true
    toc-depth: 2
    toc-title: "."
    bibliography: [bib.bib]
    css: custom.css
    code-line-numbers: true
execute:
  warning: false
  message: false  
knitr:
  opts_chunk:
    out.width: "100%"
editor_options: 
  chunk_output_type: console
editor: 
  markdown: 
    wrap: 72
---

![](img/header.png)

::: callout-note
Ce support est inspir√© en de nombreux points du manuel [G√©omatique avec
R](https://rcarto.github.io/geomatique_avec_r/) (@giraud2024). Les
exemples propos√©s sont tant√¥t adapt√©s aux contexte tunisien ou au
contexte africain. On les en remercie chaleureusement üôè
:::

<!-- #quarto-margin-sidebar { -->

### Packages utilis√©s

-   **`readxl`** : importer des fichiers Excel.
-   **`sf`** : importer, manipuler et exporter des donn√©es g√©ographiques
    vectorielles.
-   **`mapsf`** : cartographie th√©matique
-   **`units`** : Manipuler les unit√©s des objets R
-   **`dplyr`** : Manipuler les donn√©es
-   **`rmapshaper`** : simplifier des g√©om√©tries
-   **`terra`** : importer, manipuler et exporter des fichiers raster.

    <!-- -   **`rnaturalearth`** : acc√©der √† des fonds de carte du Monde. -->
    <!-- - **`geodata`** : acc√©der √† des jeux de donn√©es g√©ographiques de r√©f√©rence dans le monde.  -->
    <!-- - **`wbstats`** : utiliser les jeux de donn√©es de la Banque Mondiale via son API.  -->
    <!-- - **`osmextract`** : t√©l√©charger des donn√©es OpenStreetMap. -->
    <!-- - **`osrm`** : calculer des temps de parcours routiers via l'engin de routage OSRM.  -->

Si vous n‚Äôavez pas ces packages, vous pouvez les installer en ex√©cutant
la ligne suivante dans la console.

```{r}
#| eval: false

install.packages(c('readxl', 'sf', 'dplyr', 'units', 'rmapshaper', 'mapsf'))

```

<br>

::: {.callout-tip}
## T√©l√©charger le jeux de donn√©es
-  [tun](https://github.com/worldregio/geounivr2024/raw/refs/heads/main/datazip/tun.zip)
:::



# Les formats vectoriels - *un retour rapide*

Les donn√©es spatiales vectorielles correspondent √† une g√©om√©trie qui
peut √™tre ponctuelle, lin√©aire ou zonale. Plusieurs formats de donn√©es
g√©ospatiales existent : shapefile (shp), GeoPackage (GPKG), GeoJSON
(geojson), sqlite (sqlite), geodatabase d‚ÄôESRI (FileGDB), etc...

Nous nous attardons rapidement ici aux deux formats utilis√©s dans cette
√©cole d'√©t√©, le shapefile (shp) et le G√©oPackage (gpkg).

## Le shapefile

Le shapefile est un format de donn√©es spatiales vectorielles
propri√©taire √©dit√© par l'entreprise ESRI, il se pr√©sente comme une
collection de fichiers portant le m√™me nom avec les extensions et les
usages suivants :

-   `.shp` : stocke le format de la forme, sa g√©om√©trie
-   `.dbf` : donn√©es attributaires relatives aux g√©om√©tries du `.shp`
    contenus dans le shapefile ;
-   `.shx` : index de la g√©om√©trie.
-   `.prj` : syst√®me de coordonn√©es au format WKT (well-known text)

Chaque fichier doit porter le m√™me nom et est indispensable au bon
fonctionnement du shapefile.

D'autres fichiers annexes peuvent aussi √™tre fournis ou g√©n√©r√©s (indexes
de formes, d'attributs, m√©tadonn√©es au format xml...).

## Le GeoPackage

Le GeoPackage est un format de donn√©es spatiales vectorielles et raster
non propri√©taire et d√©fini selon les standards de l'Open Geospatial
Consortium (OGC). Il se comprend comme un fichier base de donn√©es qui
peut contenir des objets vectoriels, les tuiles d'images, des donn√©es
raster, des sch√©mas de m√©tadonn√©es comme ceux des normes INSPIRE.

Hormis le format ouvert et l‚Äôinterop√©rabilit√©, l'avantage du g√©opackage
est qu'il peut se requ√™ter comme une base de donn√©es avec du SQL dans
QGIs, R ou ailleurs, et qu'il peut stocker dans un m√™me fichier
plusieurs couches raster ou vecteur. Cela facilite grandement
l'organisation et la gestion de projets en g√©omatique.

On peut par exemple organiser son travail autour du GeoPackage de
diff√©rente fa√ßon :

-   un g√©opagkage par projet
-   un g√©opackage par echelle ou zone de travail (monde, tunisie)
-   un g√©opagkage par type d'utilisation (g√©otraitements et versionnage
    ou cartographie)

La figure suivante illustre la diff√©rence d'organisation ou
d'arborescence fichiers dans le cas d'utilisation de fichiers au format
shapefile ou G√©oPackage

![](img/arbogpkg.png)

# Le package `sf`

::: {layout="[25,75]"}
::: {first-column}
![](img/sf.gif)
:::

::: {second-column}
Le package `sf` [@pebesma2023spatial], publi√© en 2016 par Edzer Pebesma permet
l‚Äôimport, l‚Äôexport, la manipulation et l‚Äôaffichage de donn√©es spatiales
vectorielles. Pour cela `sf` s‚Äôappuie sur une s√©rie de biblioth√®ques
spatiales : GDAL (GDAL/OGR contributors, 2022), PROJ (PROJ contributors,
2021) pour les op√©rations d‚Äôimport, d‚Äôexport et de projection, et GEOS
(GEOS contributors, 2021) pour les op√©rations de g√©otraitement (buffer,
intersection‚Ä¶). Ce package propose des objets simples (suivant le
standard simple feature) dont la manipulation est assez ais√©e. Une
attention particuli√®re a √©t√© port√©e √† la compatibilit√© du package avec
la syntaxe pipe (\|\> ou %\>%) et les op√©rateurs du tidyverse (Wickham
et al., 2019).
:::
:::

## Anatomie d'un objet sf

Un objet sf se pr√©sente comme un tableau de donn√©es `data.frame`, soit
comme une table attributaire, √† laquelle on ajoute une colonne *geom* ou
*geometry* sp√©cifique, de classe `sfc` (simple feature column) contenant
les g√©om√©tries (simple feature geometry). Chaque ligne, chaque individu
est appel√© simple feature.

![](img/sfeature.png)

Dans l‚Äô√©cosyst√®me R, le `data.frame` est con√ßu comme une structure de
vecteurs. Chaque colonne correspond √† un vecteur et peut donc prendre
tous les types que peuvent prendre des vecteurs (character, integer,
numeric, boolean etc...). On peut donc effectuer sur les objets sf les
m√™me manipulations que l'on fait sur les vecteurs et tableaux dans R.

La colonne contenant les g√©om√©tries peut quant √† elle prendre les types
de g√©om√©trie traditionnels pris en charge par les
[GeoJSON](https://www.rfc-editor.org/rfc/rfc7946) :

| type                 | description                                                                                                                                                                                                                                       |
|------------------|------------------------------------------------------|
| `POINT`              | g√©om√©trie √† z√©ro dimension contenant un seul point                                                                                                                                                                                                |
| `LINESTRING`         | s√©quence de points reli√©s par des morceaux de lignes droites qui ne se coupent pas entre elles ; g√©om√©trie unidimensionnelle                                                                                                                      |
| `POLYGON`            | G√©om√©trie √† aire positive (bidimensionnelle) ; une s√©quence de points forme un anneau ferm√©, non auto-intersect√© ; le premier anneau d√©signe l'anneau ext√©rieur, z√©ro ou plusieurs anneaux suivants d√©signent des trous dans cet anneau ext√©rieur |
| `MULTIPOINT`         | ensemble de points ; un MULTIPOINT est simple si aucun des points du MULTIPOINT n'est √©gal.                                                                                                                                                       |
| `MULTILINESTRING`    | ensemble de `LINESTRING`                                                                                                                                                                                                                          |
| `MULTIPOLYGON`       | ensemble de `POLYGON`                                                                                                                                                                                                                             |
| `GEOMETRYCOLLECTION` | ensemble de g√©om√©tries de tout type sauf `GEOMETRYCOLLECTION`                                                                                                                                                                                     |

Cette colonne se pr√™te aux g√©otraitements typiques d'un SIG comme le
buffer, l'intersection ou l'agr√©gation.

## Importer et Exporter des donn√©es spatiales vectorielles avec `sf`

### Importer des donn√©es

Chargement de la librairie

```{r libSf}
#| output: false

library("sf")
```

La fonction `st_read()` de `sf` permet d'importer des formats de donn√©es
g√©ographiques vari√©s (shapefile `.shp`, GeoPackage `.GPKG`, GeoJSON
`.geojson` ...). Avant l'importation d'un fichier au format Geopackage
il est pr√©connis√© de consulter le contenu du fichier.

Pour cela on utilise la fonction `st_layers()`

```{r}
st_layers("data/tun/geom/tun_admin.gpkg")
```

<br>

Cette fonction nous donne quelques r√©sum√©s sur chacune des couches du
GeoPackage. Le nom, le type de g√©om√©trie, le nombre d'individus, le
nombre de champs, et le CRS, la projection de chaque couche.

Nous pouvons √† pr√©sent importer la couche "delegation" dans l'objet
"del"

```{r}
del <- st_read(dsn = "data/tun/geom/tun_admin.gpkg", 
               layer = "delegation")
```

## Exporter des donn√©es

`sf` peut lire plusieurs formats g√©ospatiaux et peut donc tout autant
√©crire ces formats √† l'aide de la fonction `st_write()`.

Cette fonction prend trois param√®tres indispensables en entr√©e, l'objet
√† √©crire `obj =`, son chemin d'√©criture `dsn =`, la couche √†
√©crire`layer =`.

Pour l'exercice nous allons construire un GeoPackage de projet nomm√©
`mar1Vector.gpkg`, dans lequel nous allons enregistrer notre couche
`del`.

```{r}
#| eval: false

st_write(obj = del, 
         dsn = "data/tun/mar1Vector.gpkg", 
         layer = "delegation")
```

Remarquez qu'ici le chemin d'acc√®s prend le nom complet du fichier et
son extension. Ici le nom du GeoPackage et l'extension `.gpkg`. Si nous
avions voulu exporter un GeoJSON, nous aurions √©crit
`dsn = delegation.geojson`

Quelques param√®tres additionnels sont utiles √† conna√Ætre. Par exemple
pour "√©craser" ou remplacer une couche d√©ja existante on utilise
l'argument `delete_layer = TRUE`, lorsqu'il s'agit de remplacer le
fichier `delete_dsn = TRUE`.

```{r}
#| eval: false

st_write(obj = del, 
         dsn = "data/tun/mar1Vector.gpkg", 
         layer = "delegation", 
         delete_layer = TRUE)
```

::: {callout-tip}
D'autres param√©trages sont possibles pour les autres types d'exports,
pour cela r√©f√©rez-vous √† la [vignette du
package](https://r-spatial.github.io/sf/reference/st_write.html)
:::

# Premieres explorations

## L'objet et la table attributaire (le `data.frame`)

Puisque l'objet `sf` est un `data.frame`, on peut faire des op√©rations
typiques telles que :

`head()` pour en visualiser un extrait :

```{r}
head(del)
```

`str()` pour connaitre le type ou la classe de chaque champ :

```{r}
str(del)
```

<br>

`colnames()` pour connaitre le nom chaque champ :

```{r}
colnames(del)
```

<br>

ou `summary()` pour avoir un r√©sum√© statistique de chaque champ :

```{r}
summary(del)
```

## Les g√©om√©tries

Pour connaitre le type de g√©om√©tries on utilise la fonction `st_geometry_type()`. On peut rajouter l'argument `by_geometry = FALSE` pour avoir le type de l'ensemble. 

```{r}
st_geometry_type(del, by_geometry = FALSE)
```


On peut aussi visualiser les g√©om√©tries avec la fonction `plot()` native
de R.

Dans ce premier cas on obtient une carte par champs de la table
attributaire

```{r}
plot(del)
```

Il existe deux fa√ßons de ne veut visualiser que les g√©om√©tries

::: {layout="[50, 50]"}
::: {first-column}
la fonction `st_geometry()` qui renvoi uniquement aux g√©om√©trie de
l'objet sf

`plot(st_geometry(del))`

```{r stPlot}
#| echo: false

plot(st_geometry(del))
```
:::

::: {second-column}
ou on s√©lectionne le champs contenant les g√©om√©tries

`plot(del$geom)`

```{r plotGeo}
#| echo: false

plot(del$geom)
```
:::
:::

::: callout-tip
Pour plus de d√©tail sur la cartographie avec le package sf voir le
notebook de N. Lambert con√ßu pour l'√©cole th√©matique : [Faire des cartes
th√©matiques avec
R](https://neocarto.github.io/geounivr2024/MAR_2_carto/index.html#cartographie-avec-sf){target="_blank"}
:::

# Les syst√®mes de coordonn√©es

Pour conna√Ætre le d√©tail du syst√®me de coordonn√©es de r√©f√©rence d'un
objet `sf` on utilise la fonction `st_crs()`

::: {.callout-note collapse="true"}
## D√©tail de l'ex√©ctution de la fonction st_crs()

```{r}
st_crs(del)
```
:::

Ceci nous renvoi la d√©finition compl√®te du syst√®me de coordonn√©es selon
les standards en WKT.

Mais on peut aussi r√©cup√©rer des informations sp√©cifiques relatives √† la
projection. Pour cela on utilise l'argument `parameters = TRUE`.

Il faut alors soit enregistrer le r√©sultat de cette fonction dans un
objet puis acceder aux param√®tres via l'objet...

```{r}
crsDel <- st_crs(del, parameters = TRUE)
```

::: {.callout-note collapse="true"}
## D√©tail de l'objet `crsDel`

```{r}
crsDel
```
:::

... soit acc√©der aux param√®tres directement en utilisant le `$`

```{r}
# Directement depuis la fonction
st_crs(del, parameters = TRUE)$Name
```

```{r}
# Depuis l'objet cr√©√©
crsDel$srid
```

## Changer de projection

La fonction `st_transform()` permet de changer la projection d'un objet
`sf`. Il est possible de passer d'un syst√®me de coordonn√©es g√©od√©sique √†
un syst√®me de coordonn√©es projet√©es et inversement.

Par exemple on peut reprojeter les d√©l√©gations en dans le syst√®me de
r√©f√©rence tunisien, Carthage - EPSG:2028.

```{r}
del2088 <- st_transform(del, crs = "EPSG:2088")

st_crs(del2088, parameters = TRUE)$Name
```

Ou les reprojeter en WGS84 - World Geodetic System 1984

```{r}
del4326 <- st_transform(del, crs = "EPSG:4326")

st_crs(del4326, parameters = TRUE)$Name
```

```{r}
#| code-fold: true


# Initalisation de la fen√™tre graphique
par(mfrow = c(1,3),
    mar = c(0, 2, 5, 2),
    xaxs='i', yaxs='i')

# Afficher les d√©l√©gations avec la projection initiale

# On dessine les g√©om√©tries dans leur projection d'origine
plot(st_geometry(del), border = "lightblue", lwd = 2, col = NA,
     graticule = TRUE)

# On ajoute en titre le nom de la projection et les unit√©s de mesure
title(paste0(crsDel$Name, "\n", crsDel$units_gdal))


# Carthage - EPSG:2088
plot(st_geometry(del2088), border = "lightblue", lwd = 2, col = NA,
     graticule = TRUE)

title(paste0(st_crs(del2088, parameters = TRUE)$Name, "\n",
             st_crs(del2088, parameters = TRUE)$units_gdal)
     )


# WGS84 EPSG:4326
plot(st_geometry(del4326), border = "lightblue", lwd = 2, col = NA,
     graticule = TRUE)

title(paste0(st_crs(del4326, parameters = TRUE)$Name, "\n",
             st_crs(del4326, parameters = TRUE)$units_gdal)
     )
```

Pour conserver la projection adapt√©e √† la tunisie on reprojete `del` en EPSG:2088

```{r}
del <- st_transform(del, crs = "EPSG:2088")

st_crs(del, parameters = TRUE)$Name
```

# S√©lections et jointure attributaire

## S√©lectionner par attributs

Comme les `data.frame` on peut s√©lectionner des lignes et des colonnes
des objets `sf` en utilisant les crochets :

`monSF[lignes , colonnes]`

### Selectionner des lignes

On peut donc afficher les 5 premi√®res lignes de l'objet `del` grace √†
leur index

```{r}
del[1:5,]
```

On peut aussi les s√©lectionner en fonction d'une valeur de champ. Par
exemple :

```{r}
del[del$del_nom_fr == "Sousse Medina", ]
```

### Selectionner des colonnes

On peut s√©lectionner les colonnes par leur index, par exemple pour les
derni√®res colonnes :

```{r}
del[, ncol(del)-5:ncol(del)]
```

On peut aussi les selectionner par leur nom

```{r}
del[, c("del_nom_fr", "gou_nom", "reg_nom")]
```

### Combiner les selections

Enfin on peut combiner les selections

```{r}
delSousse <- del[del$gou_nom %in% "Sousse", c("del_nom_fr", "gou_nom", "reg_nom")]

delSousse
```

Et on peut afficher cette s√©lection

```{r}

# Parametre de l'affichage
par(mar = c(0, 0, 4, 0),  xaxs='i', yaxs='i', bg = "#F1F3F5")

plot(st_geometry(delSousse), col = "#5B89A3", border = "white", lwd = 2)
title(paste(unique(delSousse$gou_nom)))
```

## Jointure attributaire

Avec la fonction `merge()` on peut joindre les donn√©es d'un autre
`data.frame` √† un objet `sf` et inversement via un champ de jointure
commun.

On importe d'autres donn√©es du projet

```{r}
# Importer les fichiers locaux
del_df <- read.csv("data/tun/don_del.csv", sep = ";", dec = ",")
```

On identifie le champ de jointure

```{r}
del[1:2,]
```

```{r}
del_df[1:2,]
```

Ici les deux colonnes identiques ont aussi le m√™me nom. On choisi
d'utiliser les codes pour la jointure :

```{r}
delMerge <- merge(x = del,
                  y = del_df, 
                  by.x = "del_code",
                  by.y = "del_code",
                  all.x = TRUE)
```

Attention, le sens de la jointure est important. Ici l'objet "x" est
l'objet auquel on joint le second. L'objet final prend le type de
l'objet x. Ici nous avons cr√©√© un nouvel objet `delMerge` qui r√©sulte de
la jointure de `del_def` √† `del`. `del_merge`prend donc le type de
`del`. C'est un objet`sf`.

La ligne `all.x` signifie que l'on conserve tous les individus du
tableau "x" meme si la correspondance est manquante dans le tableau "y".

```{r}
# Les deux objets ont bien √©t√© joints
head(delMerge, 3)
```

# S√©lections et jointure spatiale

## S√©lections spatiales

Les s√©lections spatiales s'ex√©cutent avec la fonction `st_filter()` et
selon les pr√©dicats g√©om√©triques suivants :

-   `st_intersects()`
-   `st_disjoint()`
-   `st_touches()`
-   `st_crosses()`
-   `st_within()`
-   `st_contains()`
-   `st_contains_properly()`
-   `st_overlaps()`
-   `st_equals()`
-   `st_covers()`
-   `st_covered_by()`
-   `st_equals_exact()`
-   `st_is_within_distance()`

::: callout-tip
Voir la [vignette
sf](https://r-spatial.github.io/sf/reference/geos_binary_pred.html)
:::

On importe les g√©om√©tries extraites de OSM dans le module sur la
Manipulation des donn√©es

::: callout-tip
Pour plus de d√©tail sur l'extraction de donn√©es OSM voir le notebook de
R. Ysebaert con√ßu pour l'√©cole th√©matique : [Acquisition de donn√©es
g√©ographiques et visualisations de base](){target="_blank"}
:::

```{r}
# Consulter le contenu du g√©opackage "tun_osm"
st_layers("data/tun/geom/tun_osm.gpkg")

# Charger les donn√©es ponctuelles
poi <- st_read("data/tun/geom/tun_osm.gpkg", 
               layer = "poi")

# Extrait des donn√©es charg√©es
head(poi)
```

Pour que la s√©lection spatiale fonctionne il faut s'assurer que les
deux objets poss√®dent le meme syst√®me de coordonn√©es de r√©f√©rence

```{r}
# Nom du SCR de "del"
st_crs(del, parameters = TRUE)$srid

# Nom du SCR de "poi"
st_crs(poi, parameters = TRUE)$srid
```

Ici ils ne concordent pas donc :

```{r}
# Re projection en 
poi <- st_transform(poi, crs = "EPSG:2088")

# Verification du SCR
st_crs(poi, parameters = TRUE)$srid
```

On peut maintenant r√©aliser notre s√©lection spatiale. Ici on va
s√©lectionner les points qui se trouvent dans l'objet `delSousse` que
l'on a construit plus haut.

```{r}
poiSousse <- st_filter(x = poi, 
                       y = delSousse,
                       .predicate = st_within)
```

On visualise le r√©sultat

```{r}
#| code-fold: true


# Parametre de l'affichage
par(mar = c(0, 0, 4, 0),  xaxs='i', yaxs='i', bg = "#F1F3F5")

# Initialisation de la carte √† l'emprise de Sousse
plot(st_geometry(delSousse), col = NA, border = NA)

# Fond de carte des d√©l√©gations
plot(st_geometry(del), col = "gray80", border = "white", lwd = 1, add = TRUE)

# D√©l√©gations de Soussz
plot(st_geometry(delSousse), col = "#5B89A3", border = "white", lwd = 2, add = TRUE)

# Points remarquables de Souss
plot(st_geometry(poiSousse), col = "red", border = "white", pch = 19, cex = .3, add = TRUE)

# Titre
title("Points remarquables \ndu Gouvernorat de Sousse")
```

# Op√©rations sur les g√©om√©tries

## Extraction de centroides {#sec-centro}

La fonction `st_centroid()` permet d'extraire les centroides des polygones. 

Ici on extrait les centroides des d√©l√©gations de Sousse :

```{r}
delSousse_c <- st_centroid(delSousse)
```

```{r}
# Parametre de l'affichage
par(mar = c(0, 0, 0, 0),  xaxs='i', yaxs='i', bg = "#F1F3F5")

# D√©l√©gations de Sousse
plot(st_geometry(delSousse), col = "#5B89A3", border = "white")

# Centroides des d√©l√©gations de Sousse
plot(st_geometry(delSousse_c), add = TRUE, pch = 20, col = "pink")
```

## Agr√©gation de polygones

### Agr√©gation spatiale

La fonction `st_union()` permet d'agr√©ger des polygones entre eux. Par exemple pour reconstituer le gouvernorat de Sousse

```{r}
gouSousse <- st_union(delSousse)
```

```{r}
#| code-fold: true

# Parametre de l'affichage
par(mar = c(0, 0, 0, 0),  xaxs='i', yaxs='i', bg = "#F1F3F5")

# Initialisation de la carte √† l'emprise de Sousse
plot(st_geometry(delSousse), col = NA, border = NA)

# Fond de carte des d√©l√©gations
plot(st_geometry(del), col = "gray80", border = "white", lwd = 1, add = TRUE)

# D√©l√©gations de Sousse
plot(st_geometry(delSousse), col = "#5B89A3", border = "white", lwd = 1, add = TRUE)

# Gouvernorat de Sousse
plot(st_geometry(gouSousse), border = "darkblue", lwd = 3, add = TRUE)

```

### Agr√©gation spatiale et attributaire {#sec-agreg}

On peut aussi agr√©ger les polygones et demander un r√©sum√© statistique pour un ou plusieurs champ d√©crivant ces polygones. Plusieurs m√©thodes permettent de r√©aliser cet objectif. 

La premi√®re m√©thode mobilise la fonction `aggregate()` de `sf`. Cette fonction permet d‚Äôagr√©ger les polygones et de demander **le m√™me r√©sum√© statistique** pour plusieurs champs.

Dans cet exemple nous repartons de l'objet `delMerge` issu de la fusion entre les g√©om√©tries des d√©l√©gations et le tableau additionnel. L'objectif est de construire un objet `gou` repr√©sentant les gouvernorats et leur population. Pour y arriver, nous fusionnons toutes les d√©l√©gations via le champ `gou_nom.x` et calculons la somme de la population pour chacun. 

```{r}
gou <- aggregate(
  x = delMerge[c("popto_2014", "immig_2014")], 
  by = list(gou_nom = delMerge$gou_nom.x), 
  FUN = sum
)
```

```{r}
#| code-fold: true

# Parametre de l'affichage
par(mar = c(0, 0, 0, 0),  xaxs='i', yaxs='i', bg = "#F1F3F5")

# Fond de carte des d√©l√©gations
plot(st_geometry(del), col = "gray80", border = "white", lwd = 1)

# Gouvernorats
plot(st_geometry(gou), border = "#5B89A3", lwd = 2, add = TRUE)
```


Les fonctions `group_by()` et `summarise()` du package `dplyr` permettent d'agr√©ger les polygones en demandant des r√©sum√©s statistiques **diff√©rents** selon les champs. 

```{r}
library(dplyr)

gou <- delMerge |> 
  group_by(gou_nom.x) |> 
  summarise(pop = sum(popto_2014),
            immig_mean = mean(immig_2014))
```

```{r}
gou[1:3, ]
```

 
## Construction d'une zone tampon (buffer)

Pour construire la zone tampon il est pr√©f√©rable de conna√Ætre le SCR et
l'unit√© de mesure de l'objet `sf`, par exemple avec cette fonction.

```{r}
st_crs(delSousse_c)$units
```

Les mesures sont exprim√©es en metres, on peut √† pr√©sent utiliser la
fonction `st_buffer()` pour construire la zone tampon.

Ici on peut construire une zone tampon autour du centroide de la d√©l√©gation de Sidi Bou Ali
```{r}
# S√©lection du centroide de Sidi Bou Ali 
sidiBou_c <- delSousse_c[delSousse_c$del_nom_fr %in% "Sid Bou Ali", ]
```

Et on construit la zone tampon de 3000 m soit 5km
```{r}
sidiBou_t <- st_buffer(sidiBou_c, dist = 5000)
```

```{r}
#| code-fold: true

# Parametre de l'affichage
par(mar = c(0, 0, 0, 0),  xaxs='i', yaxs='i', bg = "#F1F3F5")

# Initialisation de la carte √† l'emprise de Sousse
plot(st_geometry(delSousse), col = NA, border = NA)

# Fond de carte des d√©l√©gations
plot(st_geometry(del), col = "gray80", border = "white", lwd = 1, add = TRUE)

# D√©l√©gations de Sousse
plot(st_geometry(delSousse), col = "#5B89A3", border = "white", lwd = 1, add = TRUE)

# Gouvernorat de Sousse
plot(st_geometry(gouSousse), border = "darkblue", lwd = 3, add = TRUE)

# Zone tampon de 5km autour du centroide de Sidi Bou Ali
plot(st_geometry(sidiBou_t), border = "pink", col = "#fac0cb50", lwd = 2, add = TRUE)

# Centroide de Sidi Bou Ali
plot(st_geometry(sidiBou_c), col = "pink", pch = 20, cex = 2, add = TRUE)
```

## Intersection {#sec-inter}

La fonction `st_intersection()` permet de d√©couper une couche par une autre. 

On peut ici par exemple, d√©couper la couche `poi` des points remarquables, par le centroide de la d√©l√©gation de Sidi Bou Ali. 


```{r}
poi_sidiBou <- st_intersection(x = sidiBou_t, y = poiSousse)
```


```{r}
#| code-fold: true

# Parametre de l'affichage
par(mar = c(0, 0, 0, 0),  xaxs='i', yaxs='i', bg = "#F1F3F5")

# Initialisation de la carte √† l'emprise de Sousse
plot(st_geometry(delSousse), col = NA, border = NA)

# Fond de carte des d√©l√©gations
plot(st_geometry(del), col = "gray80", border = "white", lwd = 1, add = TRUE)

# D√©l√©gations de Sousse
plot(st_geometry(delSousse), col = "#5B89A3", border = "white", lwd = 1, add = TRUE)

# Gouvernorat de Sousse
plot(st_geometry(gouSousse), border = "darkblue", lwd = 3, add = TRUE)

# Zone tampon de 5km autour du centroide de Sidi Bou Ali
plot(st_geometry(sidiBou_t), border = "pink", col = "#fac0cb50", lwd = 2, add = TRUE)

# Centroide de Sidi Bou Ali
plot(st_geometry(sidiBou_c), col = "pink", pch = 20, cex = 2, add = TRUE)

plot(st_geometry(poi_sidiBou), col = "red", border = "white", pch = 19, cex = .5, add = TRUE)
```

## Compter les points

La fonction `st_intersects()` permet d'intersecter deux couches sans les d√©couper, et de compter les √©l√©ments d'une couche (y) contenue dans une autre (x).

L'argument `sparse = TRUE` nous permet de lister pour chaque √©l√©ment de x les objets de y.


```{r}
inter <- st_intersects(x = sidiBou_t, y = poi_sidiBou)

inter
```

Le `1: ` signifie qu'il y a un objet, une 1 liste. Les chiffres suivants sont les identifiants de chacun des points. 

Pour v√©rifier que le nombre d'intersection corresponde bien au nombre d'objets intersect√©s de x, ici il s'agit de `sidiBou_t` on fait : 

```{r}
length(inter) == nrow(sidiBou_t)
```

Pour compter le nombre de points intersect√©s par `sidiBou_t` on utilise la fonction `lengths()` qui renvoie la longueurs de chaque liste de l'intersection. 

```{r}
lengths(inter)
```

On peut ajouter cette information √† la table attributaire de sidiBou_t en cr√©ant un nouveau champ `nb_poi`
```{r}
sidiBou_t$nb_poi <- lengths(inter)
```

Sur la base de cet exemple on peut compter les points dans les gouvernorats cr√©√© dans la @sec-agreg

```{r}
interGou <- st_intersects(x = gou, y = poi)

interGou

# Le nombre d'intersections est-il √©gal aux objets de gou
length(interGou) == nrow(gou)

# combien y a t il de points par intersection
lengths(interGou)

# Ajout du nombre de points intersect√©s √† l'objet gou
gou$nb_poi <- lengths(interGou)
```

Et on peut cartographier ce r√©sultat avec le package `mapSf` 

```{r}
library(mapsf)

# intitialisation du fond de carte
mf_map(x = gou, border = "white", lwd = 0.5)

# cartographie du nombre de points en cercles proportionnels
mf_map(x = gou,
       var = "nb_poi",
       type = "prop",
       border = "white",
       col = "#FF000080",
       leg_title = "Nombre de points remarquables",
       inches   = 0.4, leg_pos  = "topright")

# Habillage
mf_layout(title = "Equipements dans les gouvernorats", arrow = TRUE, scale = TRUE, credits = "GeoUnivR 2024 - Tunisie")
```

::: callout-tip
Pour plus de d√©tail sur la cartographie avec le package `mapsf` voir le
notebook de N. Lambert con√ßu pour l'√©cole th√©matique : [Faire des cartes
th√©matiques avec
R](https://neocarto.github.io/geounivr2024/MAR_2_carto/index.html#cartographie-avec-sf){target="_blank"}
:::

## Changer de type de g√©om√©trie

Il est possible de convertir une g√©om√©trie en un autre type, par exemple convertir des g√©om√©tries de type `POLYGON` √† `LINESTRING`, avec la fonction `st_cast()` de `sf`.

Pour connaitre le type de g√©om√©tries
```{r}
st_geometry_type(del, by_geometry = FALSE)
```

Ici on converti ces `MULTIPOLYGON` en `MULTILINESTRING`

```{r}
del_line <- st_cast(del, to = "MULTILINESTRING")
```

# Unit√©s de mesures et calculs

Les mesures sont possibles lorsque l'objet `sf` √† des coordonn√©es
projet√©es. La premi√®re √©tape est donc de v√©rifier le SCR de l'objet et
son unit√© de mesure.

## Unit√©s de mesures

On peut connaitre l'unit√© de mesure de la projection avec la fonction
`st_crs()`

::: {.callout-note collapse="true"}
## D√©tail de `st_crs(del)`

```{r}
st_crs(del)
```
:::

Une m√©thode plus directe consiste √† aller chercher pr√©cis√©ment cette
information dans ce que renvoie cette fonction :

```{r }
st_crs(del, parameters = TRUE)$units_gdal
```

## Calculs

### Calcul de superficie

Pour calculer la superficie on utilise la fonction `st_area()`. Elle
renvoie une valeur dans l'unit√© de mesure de l'objet `sf`. Ici en metres
carr√©s.

```{r}
# Superficie des 5 premier-es d√©l√©gations
st_area(del[1:5, ])
```

On peut enregistrer cette information dans l'objet
```{r}
del$area <- st_area(del)
```

### Calcul de longueur

Le calcul de longueur ne s'applique qu'aux types `LINESTRING` et `MULTILINESTRING`. 

```{r}
st_length(del_line[1:5, ])

del_line$perimetre <- st_length(del_line)
```

### Calcul de distance {#sec-dist}

On peut calculer la distance entre deux points avec la fonction
`st_distance()`.

Dans le cas d'objets g√©ographiques de type `POLYGONS`, le calcul de
distance s‚Äôeffectue automatiquement entre leurs centroides. 

Le r√©sultat du calcul est une matrice de distance entre tous les points.

```{r}
st_distance(del[1:5, ])
```

Ici l'unit√© de mesure de la distance est le metre. On peut modifier
cette unit√© grace au package `units` et de la fonction `set_units()`. Il
ne s'agit pas ici de modifier l'unit√© de tout l'objet `sf` mais
seulement des objets cr√©√©s lors des calculs.

Par exemple en reprenant notre calcul de distances en metres dans un
nouvel objet :

```{r}
distances <- st_distance(del[1:5, ])
```

On peut les convertir en kilometres (km)

```{r}
# Chargement du package
library(units)

# Modification de l'unit√©
set_units(x = distances, value = km)
```

Pour que le r√©sultat soit conserv√© :

```{r}
distances <- set_units(x = distances, value = km)
```


# Aller plus loin

## Simplifier les g√©om√©tries

La fonction `st_simplify()` de `sf`permet de g√©n√©raliser des g√©om√©tries.

```{r}
del_simp_sf <- st_simplify(del, dTolerance = 5000, preserveTopology = TRUE)
```

Cett fonction n'est pas la plus √©fficiace, on peut pr√©f√©rer utiliser la fonction `ms_simplify()` du package `rmapshaper` permet de g√©n√©raliser ou simplifier les g√©om√©tries en pr√©servant la topologie.

```{r}
library(rmapshaper)

# simple g√©n√©ralisation des g√©om√©tries
del_simp_rmap <- ms_simplify(del)
```

On peut choisir la proportion de sommets √† garder avec l'argument `keep = ...`, et forcer la conservation des formes avec `keep_shapes = TRUE` 
```{r}
# Forte g√©n√©ralisation des g√©om√©tries
del_simp_rmap2 <- ms_simplify(del, keep = 0.001, keep_shapes = TRUE)
```

Voici une comparaison de g√©n√©ralisation avec diff√©rents param√®tres et avec la fonction `st_simplify()` de `sf`
```{r}

par(mfrow = c(1,4),
    mar = c(0, 1, 3, 1),
    xaxs='i', yaxs='i', 
    bg = "#F1F3F5")

plot(del$geom, col = "#5B89A3", border = "white")
title("G√©om√©tries \ninitiales")

plot(del_simp_sf$geom, col = "#5B89A3", border = "white")
title("Simplification avec sf")

plot(del_simp_rmap$geom, col = "#5B89A3", border = "white")
title("Simplification avec \nrMapshaper")

plot(del_simp_rmap2$geom, col = "#5B89A3", border = "white")
title("Forte simplification \navec rMapshaper")

```

## Agr√©ger des polygones en fonction d‚Äôune variable

## Digitalisation

La digitalisation est une √©tape utile de la manipulation de donn√©es spatiales mais n'est pas reproductible.

Certains packages de R permettent de r√©aliser ces op√©rations mais ne sont pas les plus adapt√©s car certains  de 
Digitalisation : proposer des choses et pr√©ciser que ce n‚Äôest pas reproductible et quil peut y avoir des probl√®mes de topologie et suilhy des outils plus adapt√©s √† √ßa. Qgis 

## Construction d'une grille r√©guli√®re

La fonction `st_male_grid()` permet la cr√©ation d'une grille r√©guli√®re sur l'emprise d'un objet g√©ographique donn√©.

Cette fonction renvoi un objet de type `sfc` constitu√© de listes de cellules. 
Pour le manipuler facilement on le converti en objet `sf`  avec la fonction `st_sf()` et en ajoutant un champ d'identifiants. 

```{r}
# Cr√©ation de la grille
grid <- st_make_grid(gou, cellsize = 35000)

# Ajout d'un identifiant unique et passage en sf 
grid <- st_sf(ID = 1:length(grid), geom = grid)

head(grid)
```

```{r}
par(mar = c(0, 0, 0, 0), xaxs='i', yaxs='i', bg = "#F1F3F5")
plot(st_geometry(gou), col = "#5B89A3", border = "white", lwd = 1)
plot(st_geometry(grid), col = NA, border = "black", lwd = 1, add = TRUE)
```

Il est possible de cr√©er des grilles hexagonales avec l'argument `square = FALSE`      
```{r}
grid_hex <- st_make_grid(gou, cellsize = 35000, square = FALSE)

# Ajout d'un identifiant unique et passage en sf 
grid_hex <- st_sf(ID = 1:length(grid_hex), geom = grid_hex)

# Cartographie
par(mar = c(0, 0, 0, 0), xaxs='i', yaxs='i', bg = "#F1F3F5")
plot(st_geometry(gou), col = "#5B89A3", border = "white", lwd = 1)
plot(st_geometry(grid_hex), col = NA, border = "black", lwd = 1, add = TRUE)
```

Ou de r√©cuperer le centroide de ces polygones avec l'argument `what = centers` ou les angles avec `what = corners`

```{r}
par(mar = c(0, 0, 0, 0), xaxs='i', yaxs='i', bg = "#F1F3F5")

plot(st_geometry(gou), col = "#5B89A3", border = "white", lwd = 1)

# Les centres
plot(st_make_grid(gou, cellsize = 35000, what = "centers"), col = "red", pch = 20, add = TRUE)

# Les angles
plot(st_make_grid(gou, cellsize = 35000, what = "corners"), col = "pink", pch = 3, add = TRUE)
```

### Intersecter la grille avec les points 

Comme pr√©sent√© dans la @sec-inter on peut intersecter des points dans des polygones et les compter. 

```{r}
# Intersection
inter <- st_intersects(grid, poi, sparse = TRUE) 

# v√©rifier l'intersection
length(inter) == nrow(grid)

# Jointure des r√©sultats dans la grille
grid$nb_poi <- lengths(inter)

head(grid)
```

On peut affiner cette grille en ne s√©lectionnant que les carreaux qui intersectent le fond de carte...

```{r}
grid_f <- st_filter(grid, gou, .predicate = st_intersects)
```

...et cartographier le r√©sultat avec `mapsf`
```{r}
# intitialisation du fond de carte
mf_map(x = grid_f, border = "white", lwd = 0.5)

# cartographie du nombre de points en cercles proportionnels
mf_map(x = grid_f,
       var = "nb_poi",
       type = "prop",
       border = "white",
       col = "#FF000080",
       leg_title = "Nombre de points remarquables",
       inches   = 0.4, leg_pos  = "topright")

```

## Conversion vecteur --> raster

Le package `terra` permet la manipulation de donn√©es raster mais aussi de donn√©es vecteur pour certains traitements. 

On peut convertir un objet vectoriel `sf` vers un objet vectoriel `terra` de format `spatVector` avec la fonction `vect()` de `terra` 

```{r}
library(terra)

grid_spatVect <- vect(grid)
class(grid_spatVect)
```


On peut aussi convertir un objet vectoriel `sf` vers un objet raster `terra` de format `spatRast` pour cela voir le module de raster

------------------------------------------------------------------------

::: {.callout-note title="A propos de ce document"}
Ce support a √©t√© cr√©√© pour la semaine de formation franco-tunisienne
**GEO UNIV'R Tunisie 2024 - "Enseigner la statistique, la cartographie
et l'analyse spatiale avec R** qui se tient √† Sousse en mai 2024.
:::

#### R√©f√©rences {.unnumbered}

::: {#refs}
:::

```{r sessionInfo}
sessionInfo()
```
