---
title: "GEO UNIV'R Tunisie 2024"
subtitle: "LUN3 - Acquisition de donn√©es g√©ographiques et visualisations de base"
lang: fr
date: "2024-05-13"
date-format: iso
author: "Ronan Ysebaert, Nicolas Lambert, Elina Marveaux"
format:
  html:
    embed-resources: true
    smooth-scroll: true
    fontsize: 0.9em
    toc: true
    toc-depth: 2
    toc-title: "."
    bibliography: [bib.bib]
    crossrefs-hover: false
    theme: [yeti, style.scss]
execute:
  warning: false
  message: false 
knitr:
  opts_chunk:
    out.width: "100%"
editor_options: 
  chunk_output_type: console
editor: 
  markdown: 
    wrap: 72
---

![](img/header.png)

::: {.callout-note}
Ce support est inspir√© en de nombreux points du manuel [G√©omatique avec R](https://rcarto.github.io/geomatique_avec_r/) [@giraud2024].  Et on les en remercie chaleureusement üôè. 
:::

Ce document montre les solutions techniques pour **importer**, **explorer**, **manipuler**, **visualiser** (simplement) et **exporter des donn√©es g√©ographiques avec R** :

- En **partant de rien**. 
- Avec des **tableaux de donn√©es comprenant une dimension g√©ographique** (identifiant g√©ographique).
- Avec des **couches d'information g√©ographique** (vecteur et raster).
- En utilisant des packages interfa√ßant des **API** (*Application Programming Interface*).
- En mobilisant des packages interfa√ßant **OpenStreetMap (OSM)**. 


### Packages utilis√©s

- **`readxl`** : importer des fichiers Excel.
- **`plotly`** : cr√©er des graphiques interactifs. 
- **`sf`** : importer, manipuler et exporter des donn√©es g√©ographiques vectorielles.
- **`terra`** : importer, manipuler et exporter des fichiers raster. 
- **`leaflet`** : r√©aliser une carte interactive.
- **`geodata`** : acc√©der √† des jeux de donn√©es g√©ographiques de r√©f√©rence dans le monde. 
- **`rnaturalearth`** : acc√©der √† des fonds de carte du Monde.
- **`wbstats`** : utiliser les jeux de donn√©es de la Banque Mondiale via son API. 
- **`osmextract`** : t√©l√©charger des donn√©es OpenStreetMap.
- **`osrm`** : calculer des temps de parcours routiers via l'engin de routage OSRM. 
- **`mapsf`** : r√©aliser des cartes th√©matiques (pr√©sent√© plus en d√©tail dans une autre session de formation).

Si vous n‚Äôavez pas ces packages, vous pouvez les installer en ex√©cutant la ligne suivante dans la console.

```{r install packages}
#| eval: false

install.packages(c('readxl',  'sf', 'terra', 'leaflet', 'geodata',  'wbstats', 
                   'mapsf', 'rnaturalearth', 'osmextract', 'osrm', 'plotly'))
```


### Donn√©es mobilis√©es

::: {.callout-tip}
## T√©l√©charger les donn√©es

Les exemples propos√©s dans ce support de formation sont tant√¥t adapt√©s au **contexte tunisien** ou au **continent africain**. Elles sont accessibles [ici](https://github.com/worldregio/geounivr2024/raw/refs/heads/main/datazip/data_intro.zip). Le dossier `/data_intro` du d√©p√¥t est organis√© comme suit.
:::



<br><center>

![](img/data.png)

</center>

<br>

# *"From scratch"*

En partant de rien et avec quelques lignes de code on peut **cr√©er un jeu de donn√©es spatial** pour en faire, par exemple, une carte interactive. 

Trois vecteurs sont cr√©√©s, puis transform√©s en `data.frame` et enfin convertis en objet spatial avec la fonction `st_as_sf()` du package `sf`. Cela permet de cr√©er rapidement une carte interactive avec le package `leaflet`. 

```{r from_scratch}
# 3 vecteurs avec nom, longitude et latitude
name <- c("Sentido Bellevue Park", "Universit√© de Sfax", "Universit√© Paris Cit√©")
long <- c(10.579, 10.742, 2.382)
lat <- c(35.913, 34.736, 48.827)

# Transformer en data.frame
loc <- data.frame(name, long, lat)

# Transformer en objet spatial
library(sf)
loc <- st_as_sf(loc, 
                coords = c("long", "lat"),
                crs = 4326)

# Visualiser simplement avec leaflet
library(leaflet)

leaflet(loc) |> 
  addTiles() |> 
  addCircleMarkers(popup = loc$name) # H√¥pitaux

```


<br>

# Tableaux de donn√©es

## Import .csv

Import des donn√©es des d√©l√©gations au format csv. On lui donne le nom de `del_df`.

```{r import_csv}
del_df <- read.csv("data/data_intro/tun/data/don_del.csv", sep = ";", dec = ",")
```

Avec R, il est tr√®s important de ma√Ætriser la nature des objets import√©s ou transform√©s, et les convertir le cas √©ch√©ant. La fonction `class()` nous permet de constater qu'il s'agit d'un `data.frame`. La fonction `str()` permet de d√©tailler son contenu.  

```{r R_objects}
class(del_df)
str(del_df)
```

On visualise les premi√®res lignes avec la fonction `head()`.

```{r head_object}
head(del_df, 5)
```


## Import Excel

La package `readxl` permet l'import de fichiers Excel. La fonction `read_excel` a plusieurs arguments utiles pour sp√©cifier en entr√©e le format des colonnes (texte, num√©rique), ne pas consid√©rer les *n* premi√®res lignes du fichier, etc. 

Nous importons ici un fichier Excel d√©riv√© du [*World Population Prospects*](https://population.un.org/wpp/Download/Standard/Population/) des Nations Unies, qui met √† disposition toute sorte d‚Äôindicateurs d√©mographiques (population, natalit√©, mortalit√©). On dispose ici des d√©nombrements de population par tranche d‚Äô√¢ge quinquennale de 1950 √† 2021 (feuille *estimates*).

```{r import_excel}
library(readxl)

world <- read_excel("data/data_intro/world/data/unpp_POP_5y.xlsx", 
                 sheet = "Estimates",
                 skip = 16,
                 col_types = c(rep("text", 10), rep("numeric", 22))) 
```

## Manipulation de `data.frame`

Dans les faits ces fichiers n√©cessitent g√©n√©ralement d'√™tre reformat√©s et r√©organis√©s pour pouvoir √™tre interpr√©t√©s dans un logiciel quel qu'il soit... Commen√ßons par comprendre la structure des donn√©es : noms de colonnes, ann√©es disponibles etc.

```{r data_frame_classes}
# Conversion en data.frame
world <- data.frame(world)

# Nom des colonnes
colnames(world)

# Ann√©es disponibles
unique(world$Year)
```

On peut alors filtrer les dimensions du tableau, calculer des indicateurs, etc. qui pourront √™tre utilis√©s pour des statistiques de base, des graphiques voire de futures repr√©sentations cartographiques.

```{r data_frame_handling}
# Somme de plusieurs colonnes
world$POP_TOT <- rowSums(world[,c(12:32)]) # Population totale

# Renommer une colonne
names(world)[3] <- "Name"

# Cr√©er des indicateurs
# Part des jeunes
world$YOUNG_RT <- (world$X0.4 + world$X5.9 + world$X10.14) / world$POP_TOT * 100 
# Part des personnes √¢g√©es
world$OLD_RT <- (world$X65.69 + world$X70.74 + world$X75.79 + world$X80.84 +
                   world$X85.89 + world$X90.94 + world$X95.99) / world$POP_TOT * 100 

# S√©lection d'une ligne
world_2021 <- world[world$Year == 2021,] # Ann√©e de r√©f√©rence

# S√©lectionner plusieurs lignes
afr <- c("910", "911", "912", "913", "914")
afr_2021 <- world_2021[world_2021$Parent.code %in% afr,] # Pays africains

# Ordonner selon les valeurs d'une colonne
afr_2021 <- afr_2021[order(afr_2021$YOUNG_RT, decreasing = TRUE),]
```

Il existe de nombreuses fonctions pour l'analyse statistique avec R. La plus basique √©tant probablement `summary()`. 

```{r summary}
# R√©sum√© stat
summary(afr_2021)
```


::: {.callout-tip collapse="true"}

## L'int√©r√™t de la programmation pour manipuler des donn√©es

Les fournisseurs de donn√©es institutionnels distribuent parfois des tableaux de donn√©es peu adapt√©s √† l'int√©gration dans un logiciel quel qu'il soit. La mise en forme des donn√©es dans un langage de programmation permet : 

- d'√©viter d'avoir √† manipuler ces fichiers manuellement, source d'erreurs.
- d'avoir un fa√ßon g√©n√©rique et rapide d'importer un grand nombre de tableaux de donn√©es.

Voici le fichier d'origineproduit par l'Institut National de la Statistique tunisien (INS) qui pr√©sente le nombre de ch√¥meurs par sexe et niveau d'instruction par gouvernorat tunisien (INS) : 

<center>![](img/data_chom_gouv.png)</center>

Un court bloc de code permet de r√©organiser le fichier comme d√©sir√©, et pourrait √™tre utilement √©tendu aux autres fichiers distribu√©s par l'INS. 

```{r tunisian_data_handling}
# Import
input_gouv <- read_excel("data/data_intro/tun/data/chomage.xls", # Chemin du fichier
                         sheet = "Sheet1", # Nom de la feuille Excel
                         skip = 3, # Retirer les trois premi√®res lignes
                         col_types = c(rep("text", 3), rep("numeric", 6))) # Format des colonnes 

# Table de passage Recensement / codes internationaux
gouv <- read.csv("data/data_intro/tun/data/code_tun.csv")

# Reformatage
input_gouv <- data.frame(input_gouv)
input_gouv[,1:2] <- NULL # Retirer les deux premi√®res colonnes

# Noms de colonnes
cols <- c("CHOM_INS_NON_", "CHOM_INS_PRI_", "CHOM_INS_SEC_", "CHOM_INS_SUP_",
          "CHOM_INS_UNK_", "CHOM_INS_TOT_") 
colnames(input_gouv)[1] <- "id_TUN"

# Ch√¥meurs
# Hommes
tmp1 <- input_gouv[c(1:25),]
names(tmp1)[2:length(tmp1)] <- paste0(cols, "M")
gouv <- merge(gouv, tmp1, by = "id_TUN", all.x = TRUE)

# Femmes
tmp2 <- input_gouv[c(26:50),]
names(tmp2)[2:length(tmp2)] <- paste0(cols, "F")
gouv <- merge(gouv, tmp2, by = "id_TUN", all.x = TRUE)
```

Une fois mis en forme, on peut r√©aliser un graphique **sans avoir modifi√© le fichier initial provenant de l'INS**. 

```{r tunisian_boxplot}
#| fig-cap: "Nombre de ch√¥meurs dans les gouvernorats tunisiens par niveau d'√©ducation"
# 2 graphiques par ligne
par(mfrow = c(1,2), mar = c(2,2,2,2))

# Boxplot hommes
boxplot(gouv$CHOM_INS_NON_M, # Ch√¥meurs hommes par niveau d'instruction
        gouv$CHOM_INS_PRI_M, 
        gouv$CHOM_INS_SEC_M,
        gouv$CHOM_INS_SUP_M, 
        ylim = c(0, 12000), # Bornes min/max de l'axe des ordonn√©es
        main = "Hommes", # Titre plot
        names = c("Rien", "Primaire", "Secondaire", "Tertiaire"), # Labels (X)
        ylab = "Nombre de ch√¥meurs, 2014", # Label (Y)
        col = "#adcaf7", # Couleur des box-plots
        cex.axis = .6, # Taille des labels des axes (r√©duit de 70 %)
        cex.title = .6) # Taille du label du titre (r√©duit de 70 %)

# Boxplot femmes
boxplot(gouv$CHOM_INS_NON_F, 
        gouv$CHOM_INS_PRI_F, 
        gouv$CHOM_INS_SEC_F,
        gouv$CHOM_INS_SUP_F,
        ylim = c(0, 12000),
        main = "Femmes",
        names = c("Rien", "Primaire", "Secondaire", "Tertiaire"), 
        col = "#ed9fb0", 
        cex.axis = .6, 
        cex.title = .6)
```

:::

## Export

`write.csv()` exporte un `data.frame` selon un chemin sp√©cifi√©. 

```{r write_csv}
#| eval: false
write.csv(x = gouv, # Objet √† exporter
          file = "data/tun/data/gouv_chom.csv", # Chemin de fichier 
          row.names = FALSE) # Pour retirer les num√©ros de ligne
```


## Graphiques de base

Les possibilit√©s offertes en terme de repr√©sentations graphiques sont nombreuses avec R ! En une ligne de code on peut cr√©er des repr√©sentations graphiques vari√©es. 

On s'int√©resse ici √† la part des jeunes (0-14 ans, *YOUNG_RT*) et √† la part des personnes √¢g√©es (65 ans et plus, *OLD_RT*) des pays africains dans la population totale en 2021.

```{r plot_r_base} 
par(mar = c(2,2,2,2), mfrow = c(2, 3))

barplot(afr_2021$YOUNG_RT, main = "Diagramme en barre")
boxplot(afr_2021$YOUNG_RT, main = "Bo√Ætes √† moustache")
hist(afr_2021$YOUNG_RT, main = "Histogrammes")
hist(afr_2021$YOUNG_RT, freq = FALSE, main = "Histogrammes et densit√©")
lines(density(afr_2021$YOUNG_RT), col = "blue")
stripchart(afr_2021$YOUNG_RT, method = "jitter", pch = 16,
           main = "Diagrammes de dispersion")
plot(data = afr_2021, YOUNG_RT ~ OLD_RT, main = "Nuages de points")
```

Ces graphiques sont param√©trables avec une s√©rie d'arguments graphiques.   

```{r plot_r_base_params}
par(mar = c(4,4,0,4))

# Line plot
tun <- world[world$Name == "Tunisia",]
alg <- world[world$Name == "Algeria",]
mar <- world[world$Name == "Morocco",]

plot(alg$Year, # Abscisses 
     alg$YOUNG_RT, # Ordonn√©es
     type = "l", # Type lignes
     ylim = c(20, 50), # Bornes min/max des ordonn√©es
     cex = .6, # Taille des points
     col = "blue", # Couleur de la ligne
     cex.lab = 0.7, # R√©duit les labels d'un facteur de 0.7
     cex.axis = 0.6, # R√©duit les labels des graduations d'un facteur de 0.6 
     xlab = "Ann√©es", # Label abscisses 
     ylab = "Part des jeunes (%) dans la population totale") # Label ordonn√©es

lines(mar$Year, 
      mar$YOUNG_RT, # Rajouter une ligne (Maroc)
      col = "darkgreen", 
      type = "l",
      cex = .6)

lines(tun$Year,  # Et Tunisie
      tun$YOUNG_RT, 
      type = "l", 
      cex = .6,
      col = "red")

# Organisation de la l√©gende
legend(x = "topright",
       legend = c("Alg√©rie", "Maroc", "Tunisie"),
       col = c("blue", "darkgreen", "red"), lty = 1,
       cex = .8)
```


## Graphiques interactifs

Le package `plotly` [@R-plotly] permet d'associer aux graphiques une dimension interactive. Pour utiliser les fonctions de ce package, il faut bien avoir en t√™te le format de donn√©es attendu (format long). 

```{r plotly}
library(plotly)

# Importer jeu de donn√©es d'exemple de gapminder
gap <- read.csv("data/data_intro/world/data/gapminder.csv")

head(gap)

# Param√©trage des cercles proportionnels
area_max <- 2000 # Diam√®tre maximal
area_min <- area_max/(max(gap$pop)/min(gap$pop)) # Diam√®tre minimal

# Cr√©er un graphique de type "Multiple Trace Animations"
fig <- gap %>%
  plot_ly(
    x = ~gdpPercap, # Variable X
    y = ~lifeExp,   # Variable Y
    size = ~pop,    # Taille des cercles 
    color = ~continent,  # Couleur des cercles 
    frame = ~year, # Animation temporelle 
    sizes = c(area_min, area_max), # Gestion taille cercles
    marker = list(opacity = 0.5, sizemode = 'area'), # Taille et opacit√©
    text = ~country,  #  Nom du champ qui s'affichera interactivement
    hoverinfo = "text", 
    type = 'scatter', # Type de graphique
    mode = 'markers' # Mode de repr√©sentation des figur√©s
  )

# Param√©trer l'√©chelle, les labels, etc.
fig <- fig %>% layout(
    xaxis = list(type = "log", title = "PIB par habitant"),
    yaxis = list(title = "Esp√©rance de vie")
  )

fig
```


:::{.callout-note title="Pour aller plus loin" collapse="true"}

[r-graph-gallery](https://r-graph-gallery.com/index.html) pr√©sente les possibilit√©s graphiques les plus courantes, en langage de base R. L'exploration de la syntaxe `ggplot`et son package de r√©f√©rence [ggplot2](https://ggplot2.tidyverse.org/index.html) peut √™tre utile pour la recherche de repr√©sentations graphiques avanc√©es. Cette syntaxe est un peu diff√©rente du langage de base R et repose sur les principes de la "grammaire des graphiques". Plusieurs manuels tr√®s bien construits permettent de rentrer dans l'univers de la visualisation de donn√©es avec `ggplot2`, comme [Modern Data Visualization with R](https://rkabacoff.github.io/datavis/) [@kabacoff]

![*Transition Plot* r√©alis√© avec les packages `ggplot2` et `ggallivial` (R. Ysebaert, 2024)](img/transition_plot.png)
:::

<br>

# Donn√©es vectorielles

Le package **[`sf`](https://r-spatial.github.io/sf/)** permet d'importer et manipuler des couches g√©ographiques vectorielles (points, lignes, polygones). 

## Import

Le [geopackage](https://kost-ceco.ch/cms/kad_geopackage_fr.html#:~:text=1.2.1-,Description,.opengeospatial.org%2F) est un format de donn√©es ouvert  qui permet de stocker plusieurs couches g√©ographiques dans un m√™me fichier. La fonction `st_layers()` permet d‚Äôavoir un aper√ßu des couches pr√©sentes dans un geopackage.  

```{r st_layers}
library(sf)

st_layers("data/data_intro/tun/geom/tun_admin.gpkg")
```

Importer des couches g√©ographiques avec `st_read()`. 

```{r import_sf}
del <- st_read("data/data_intro/tun/geom/tun_admin.gpkg", layer = "delegation", quiet = TRUE)
gouv <- st_read("data/data_intro/tun/geom/tun_admin.gpkg", layer = "gouvernorat", quiet = TRUE)
reg <- st_read("data/data_intro/tun/geom/tun_admin.gpkg", layer = "region", quiet = TRUE)
```

Il s'agit bien d'objets `sf`. 

```{r class_sf}
class(del)
```

La fonction `st_read()` peut aussi √™tre employ√©e pour des formats de fichiers .geojson, .shapefiles, etc. 

```{r import_geojson}
reg <- st_read("data/data_intro/tun/geom/map_reg.geojson", quiet = TRUE) 
```

Les objets `sf` sont des `data.frame` dont l‚Äôune des colonnes contient des g√©om√©tries. Cette colonne est de la classe `sfc` (simple feature column) et chaque individu de la colonne est un `sfg` (simple feature geometry).

```{r head_sf}
head(del)
```

## Affichage

Aper√ßu des variables avec `plot()` :

```{r plot_sf}
plot(del)
```

Afficher juste les g√©om√©tries:

```{r plot_geom}
#| fig-height: 4

# 3 cartes par ligne
par(mfrow = c(1,3), mar = c(2,2,2,2))

# D√©l√©gations
plot(del$geom, # G√©om√©tries uniquement
     col = "peachpuff", # Couleur du fond
     border = "white", # Couleur de bordure
     main = "D√©l√©gations") # Titre

# Gouvernorats
plot(gouv$geom, 
     col = "peachpuff", 
     border = "white",
     main = "Gouvernorats")

# "R√©gions"
plot(reg$geom, 
     col = "peachpuff",
     border = "white",
     main = "R√©gions")
```

## Manipulations de base

### Jointures attributaires

Nous pouvons joindre un `data.frame` √† un objet `sf` en utilisant la fonction `merge()` et en s‚Äôappuyant sur des identifiants communs aux deux objets.

Attention √† l‚Äôordre des arguments, l‚Äôobjet retourn√© sera du m√™me type que `x`. Il n‚Äôest pas possible de faire une jointure attributaire en utilisant deux objets `sf`.

```{r merge}
del <-  merge(
  x = del[,"del_code"],  # L'objet sf (seulement le champ del_code)
  y = del_df,          # le data.frame
  by.x = "del_code",  # identifiant dans x
  by.y = "del_code",  # identifiant dans y
  all.x = TRUE         # conserver toutes les lignes
)

head(del)
plot(del[,"idr_2011"])
```

### S√©lectionner des lignes, des colonnes

Les objets `sf` sont des `data.frame`, on peut donc s√©lectionner leur lignes et leur colonnes de la m√™me mani√®re.

```{r sf_select}
# S√©lection de lignes
sou <- del[del$gou_nom == "Sousse",]

# S√©lection de colonnes
sou <- sou[,"idr_2011"]

# Ne conserver que les lignes avec une valeur
sou <- sou[!is.na(sou$idr_2011),]

plot(sou[,"idr_2011"])
```

## Export

```{r sf_export}
#| eval: false
st_write("data/data_intro/tun/geom/sousse_deleg.geojson")
```

<br>

# Donn√©es raster

Le package `terra` [@R-terra] permet d‚Äôimporter et d‚Äôexporter des fichiers raster. Il repose sur la biblioth√®que GDAL [@GDAL] qui permet de lire et de traiter un tr√®s grand nombre de format d‚Äôimages g√©ographiques.

## Import 

La fonction `rast()` permet de cr√©er et/ou d‚Äôimporter des donn√©es raster. Nous importons ici un jeu de donn√©es au format .tif cr√©√© et distribu√© par [WorldPop](https://hub.worldpop.org/geodata/summary?id=39268) qui porte sur une estimation de la population tunisienne dans une r√©solution d'1 km (aussi accessible [√† 100 m√®tres](https://hub.worldpop.org/geodata/summary?id=29291)). 

```{r import_terra}
library(terra)
pop <- rast("data/data_intro/tun/geom/pop.tif")
```

Ce sont des objets de type `SpatRaster`. 

```{r class_terra}
pop
```

La fonction `summary()` est toujours utile pour un r√©sum√© statistique des cellules. Vu le nombre important de cellules, ce r√©sum√© est effectu√© sur un √©chantillon. 

```{r summary_terra}
summary(pop)
```

## Affichage

Par d√©faut et comme montr√© pr√©c√©demment, la fonction `plot()` renvoie une l√©gende continue sur les repr√©sentations cartographiques. On peut choisir de discr√©tiser cette information pour repr√©senter des classes de valeur associ√©e √† une palette de couleurs personnalis√©e. 
```{r plot_terra}
par(mfrow = c(1,2))

# Graphique en √©chelle continue
plot(pop)

# Avec discr√©tisation et param√©trage des couleurs
cuts <- c(0, 5, 25, 50, 250, 500, 2000, 18879)
cols <- colorRampPalette(c("yellow", "darkgoldenrod1", "brown2"))
plot(pop, breaks = cuts, col = cols(7))
```


## Manipulation de base

Le d√©coupage d‚Äôun raster en fonction de l‚Äô√©tendue d‚Äôun autre objet, SpatVector ou SpatRaster, est r√©alisable avec la fonction `crop()`. Les deux couches de donn√©es doivent √™tre dans la m√™me projection.

```{r crop_terra}
# Transformer en WGS 84
sou <- st_transform(sou, 4326)

# Crop avec la d√©l√©gation de Sousse
pop_sou <- crop(pop, sou)

# Plot
plot(pop_sou, breaks = cuts, col = cols(8))
plot(sou$geom, col = NA, add = TRUE)
```

## Export

La fonction `writeRaster()` permet d‚Äôenregistrer un objet `SpatRaster`.

```{r export_terra}
#| eval: false
writeRaster(x = pop_sou, filename = "data/data_intro/tun/geom/pop_sou.tif")
```

<br>

# Packages de donn√©es spatiales

De nombreux packages distribuent des donn√©es g√©ographiques. Ils interfacent souvent des API qui permettent d'interroger des donn√©es mises √† disposition sur le Web, directement avec R.

L'int√©r√™t des API est de se connecter directement aux bases de donn√©es des fournisseurs de donn√©es, et de disposer des derni√®res mises √† jour des donn√©es. 

::: {.callout-tip collapse="true"}

## Principaux packages

### Au niveau international

- `rnaturalearth` [@R-rnaturalearth] : permet de r√©cup√©rer les donn√©es cartographiques [Natural Earth](https://www.naturalearthdata.com/).   
- `cshapes` [@R-cshapes] : met √† disposition les fronti√®res nationales, de 1886 √† aujourd'hui.  
- `geonames` [@R-geonames] : permet d'interroger la BD [geonames](http://www.geonames.org/), qui fournit notamment des localisations.
- `wbstats` [@R-wbstats] et `WDI` [@R-WDI] : donnent acc√®s aux donn√©es et statistiques de la Banque mondiale.   
- `sen2r` [@R-sen2r] : permet de t√©l√©charger et pr√©traiter automatiquement les donn√©es du satellite Sentinel-2.   
- `MODIStsp` [@R-MODIStsp] : permet de trouver, t√©l√©charger et traiter des images *MODIS*.
- `geodata` [@R-geodata] : fournit un acc√®s √† des [donn√©es](https://github.com/rspatial/geodata) sur le climat, l'altitude, le sol, la pr√©sence d'esp√®ces et les limites administratives. 
- `elevatr` [@R-elevatr] : donne acc√®s √† des donn√©es d'√©l√©vation mises √† disposition par [*Amazon Web Services Terrain Tiles*](https://registry.opendata.aws/terrain-tiles/), l'[*Open Topography Global Datasets API*](https://opentopography.org/developers/) et l'[*USGS Elevation Point Query Service*](https://nationalmap.gov/epqs/).
- `rgee` [@R-rgee] : permet d'utiliser l'API de [Google Earth Engine](https://www.google.com/intl/fr_in/earth/education/tools/google-earth-engine/), catalogue de donn√©es publiques et infrastructure de calcul pour les images satellites.   
- `nasapower` [@R-nasapower] : API client *NASA* (pr√©vision des ressources √©nerg√©tiques mondiales, m√©t√©orologie, √©nergie solaire de surface et climatologie). 
- `geoknife` [@R-geoknife] : permet de traiter (en ligne) des donn√©es matricielles volumineuses issues du *Geo Data Portal* de l'*U.S. Geological Survey*.
- `rdhs` [@R-rdhs] : API client et gestions de donn√©es de l'[enqu√™te d√©mographique et de sant√© (DHS)](https://dhsprogram.com/).
- `giscoR` [@R-giscoR] : permet de t√©l√©charger des donn√©es cartographiques mondiales et europ√©ennes de la BD [GISCO](https://ec.europa.eu/eurostat/web/gisco) d'Eurostat (syst√®me d'information g√©ographique de la Commission). 
- `eurostat` [@R-eurostat] : permet de t√©l√©charger des donn√©es de la BD [Eurostat](https://ec.europa.eu/eurostat).    
  

### Au niveau national

- **Br√©sil**
  - `geobr` [@R-geobr] : fournit un acc√®s facile aux s√©ries de donn√©es spatiales officielles du Br√©sil pour diff√©rentes ann√©es et d√©coupage administratifs. 
- **Chili**
  -`chilemapas` [@R-chilemapas] : donne acc√®s aux  divisions politiques et administratives du Chili. 
- **Espagne** 
  - `mapSpain` [@R-mapSpain] : propose les limites administratives de l'Espagne √† plusieurs niveaux (Communaut√©s autonomes, Provinces, Municipalit√©s), ainsi que des tuiles.
- **√âtats-Unis**
  - `tidycensus` [@R-tidycensus] : permet de charger des donn√©es et g√©om√©tries du recensement am√©ricain en format `sf` et `tidyverse`
  - `tigris` [@R-tigris] : donne acc√®s aux √©l√©ments cartographiques fournis par le US Census Bureau TIGER, y compris les limites cartographiques, les routes et l'eau.
  - `FedData` [@R-FedData] : automatise le t√©l√©chargement de donn√©es g√©ospatiales disponibles √† partir de plusieurs sources de donn√©es f√©d√©r√©es.
  - `acs` [@R-acs] : permet de t√©l√©charger et manipuler les donn√©es de l'*American Community Survey* et les donn√©es d√©cennales du recensement des √âtats-Unis.
  - `censusapi` [@R-censusapi] : wrapper pour les API du *Census Bureau* des √âtats-Unis.
  - `idbr` [@R-idbr] : interface avec l'API de la base de donn√©es internationale du US Census Bureau.  
  - `ipumsr` [@R-ipumsr] : Permet d'importer des donn√©es de recensement, d'enqu√™te et g√©ographiques fournies par l'[IPUMS](https://www.ipums.org/).
  - `totalcensus` [@R-totalcensus] : permet d'extraire les donn√©es du recensement d√©cennal et de l'*American Community Survey* au niveaux des *block*, *block group* et *tract*.
- **Finland**
  - `mapsFinland` [@R-mapsFinland] : donne un acc√®s √† des cartes et donn√©es concernant la Finland.
- **France**
  - `happign` [@R-happign] : acc√®s √† certaines donn√©es de l'IGN.
  - `insee` [@R-insee] : pour t√©l√©charger facilement les donn√©es de la base BDM ([Banque de Donn√©es Macro√©conomiques](https://www.data.gouv.fr/fr/reuses/insee-package-r/)) de l'INSEE.
- **Pologne**
  - `rgugik` [@R-rgugik] : permet l'acquisition automatique de donn√©es ouvertes √† partir des ressources du Bureau central polonais de la g√©od√©sie et de la cartographie ([G≈Ç√≥wny UrzƒÖd Geodezji i Kartografii](https://www.gov.pl/web/gugik) ).  
- **Uruguay**
  - `geouy` [@R-geouy] : permet le chargement d'informations g√©ographiques sur l'Uruguay.
- ...

:::

## geodata

Ce package facilite l'acc√®s √† des donn√©es g√©ographique de r√©f√©rence sur le climat, la couverture du sol, les limites administratives et plusieurs autres jeux de donn√©es de r√©f√©rence au niveau mondial. 

::: {.callout-note collapse="true"}

## Les couches g√©ographiques inclues dans le package `geodata`

|Function                        |Description                                                                                                     |
|:---------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------|
|`bio_oracle`                 |Marine data from [Bio-Oracle](https://bio-oracle.org/) |
|`cmip6_world`, `cmip6_tile`  |Downscaled and calibrated CMIP6 projected future climate data                            |
|`country_codes`                |Country codes                                                                |
|`crop_calendar_sacks`          |Crop calendar data by [Sacks et al](https://sage.nelson.wisc.edu/data-and-models/datasets/crop-calendar-dataset/)     |
|`crop_monfreda`                |Crop area and yield data for 175 crops by [Monfreda et al.](http:://www.earthstat.org/harvested-area-yield-175-crops/)    |
|`crop_spam`                    |[MapSPAM](https://www.mapspam.info/data/) crop data (area, yield, value)     |
|`cropland`                       |Cropland density for the world derived from different sources (ESA, GLAD, QED) |
|`elevation_3s`, `elevation_30s`, `elevation_global`       |Elevation data                                                                  |
|`gadm`, `world`   |Administrative boundaries for any country, or the entire world from [GADM](https://gadm.org) |
|`landcover`                    |Landcover data derived from ESA WorldCover |
|`footprint`                    |Human footprint data from the [Last of the Wild project](https://sedac.ciesin.columbia.edu/data/collection/wildareas-v3) |
|`osm`                          |OpenStreetMap data by country (places and roads) |
|`population`                   |Population density [Gridded Population of the World](http://sedac.ciesin.columbia.edu/data/collection/gpw-v4/documentation)    |
|`soil_af`            |Chemical and physical soil properties data for Africa for different soil depths  |
|`soil_af_elements`             |Connect to or download chemical soil element concentration (for the 0-30 cm topsoil) data for Africa  |
|`soil_af_water`                |Physical soil properties data for Africa for water balance computation  |
|`soil_af_isda`                 |Soil data for Africa derived from the [iDSA data set](https://envirometrix.nl/isdasoil-open-soil-data-for-africa/)   |
|`soil_world_vsi`               |Virtually connect to the global [SoilGrids](https://www.isric.org/explore/soilgrids) data        |
|`soil_world`                   |Global soils data from [SoilGrids](https://www.isric.org/explore/soilgrids) |
|`sp_occurrence`                |Species occurrence records from the [Global Biodiversity Information Facility](https::/www.gbif.org) |
|`travel_time`                  |Travel time to and from cities and ports by [Nelson et al.](https://www.nature.com/articles/s41597-019-0265-5)   |
|`worldclim_global`, `worldclim_country`, `worldclim_tile` |[WorldClim](https://worldclim.org) glocal climate data     |

:::

Extraction des couches g√©ographiques d'altitude et de temp√©rature en Tunisie. 

```{r import_geodata}
#| eval: false

library(geodata)
elev <- elevation_30s(country = "TUN", path = tempdir())
temp <- worldclim_country(country = "Tunisia", 
                          res = 10, 
                          var = "tavg",
                          path = tempdir())
```

```{r import_geodata_hide}
#| echo: false

elev <- rast("data/data_intro/tun/geom/elevation.tif")
temp <- rast("data/data_intro/tun/geom/temp.tif")
```

Ce sont des objets de type `SpatRaster`.

```{r class_geodata}
class(temp)
class(elev)
```

```{r plot_geodata}
# Les afficher
par(mfrow = c(1,2))

# Altitude
cols <- colorRampPalette(c("#31ad37", "#f5f752", "#fca330", "#9c5903"))
plot(elev, main = "Altitude", col = cols(50))
     
# Temp√©rature
cols <- colorRampPalette(c("#4575b4", "#91bfdb", "#e0f3f8", 
                           "#fee090", "#fc8d59", "#d73027"))
plot(temp$TUN_wc2.1_30s_tavg_5, main = "Temp√©ratures, Mai (1970-2000)",
     col = cols(50))
```


## Natural Earth et Banque Mondiale.

::: {.callout-tip}
## Objectif

Nous cherchons ici √† cr√©er une carte de la part de la couverture foresti√®re en Afrique en utilisant les donn√©es de la banque mondiale et le fond de carte Natural Earth. Rien besoin de t√©l√©charger, mais il faut une connexion internet. 

:::

Plusieurs fonds de carte des pays du Monde √† diff√©rents niveaux de g√©n√©ralisation cartographique sont disponibles avec la package `rnaturalearth`. Nous s√©lectionnons uniquement les pays africains. 

```{r import_naturalearth}
library(rnaturalearth)

# Import des pays
country <- ne_countries(type = "countries", # pays
                        scale = "small",  # niveau de g√©n√©ralisation
                        returnclass = "sf") # objet retourn√©

# Conversion en projection Mercator
country <- st_transform(country, crs = "EPSG:3857")

# Si on s'int√©resse √† l'Afrique (mod√®le carto)
afr <- country[country$continent == "Africa",]
```

Le package `wbstats `permet d‚Äôinterroger l‚ÄôAPI de la base de donn√©es de la Banque Mondiale.  On peut faire une recherche pour trouver le nom des tables qui r√©pondent √† une requ√™te par mots-cl√©s avec la fonction `wb_search()`.

```{r search_wbstats}
library(wbstats)

wb_search("Forest.area")
```


::: {.callout-warning}
Chaque package reposant sur une API a son fonctionnement propre. Il est donc conseill√© de consulter attentivement la documentation associ√©e √† ces packages (souvent pr√©cise) pour apprendre √† les utiliser. Par ailleurs les validit√© des extractions r√©alis√©es est d√©pendante des fournisseurs de donn√©es. Si le contenu de la base de donn√©e √©volue (organisation, nom des indicateurs, etc.), le code R sur lequel repose l'extraction des donn√©es peut ne plus s'ex√©cuter correctement avec le temps. Pour √©viter ce type de d√©sagr√©ment, il peut √™tre utile de sauvegarder le r√©sultat de l'export des donn√©es.  
:::

La fonction `wb_data()` extrait la table de la banque Mondiale qui nous int√©resse. 

```{r import_wbstats}
# S√©lection des indicateurs
wb <- wb_data("AG.LND.FRST.ZS", return_wide = FALSE)
head(wb)
```

La fonction `reshape()` est utilis√©e pour transformer le `data.frame` dans un format plus conforme √† nos habitudes (long vers large) : les pays dans la premi√®re colonne, puis la s√©rie temporelle disponible en colonnes. 

```{r select_wbstats}
# Ordonner par ann√©e
wb <- wb[order(wb$date),]

# S√©lectionner les colonnes d'int√©r√™t
wb <- data.frame(wb[,c("iso3c", "date", "value")])

# Reformater au format long
wb <- reshape(wb, 
              idvar = "iso3c", # identifiants
              timevar = "date", # variable contenant les dates 
              direction = "wide") # format long

# R√©sultat pour quelques colonnes
head(wb[,c("iso3c", "value.2020", "value.2021", "value.2022", "value.2023")])
```

Nous cherchons l'ann√©e la plus r√©cente pour laquelle nous disposons d'un maximum de valeurs. Cette ligne de code permet de d√©nombrer le nombre de NA pour chaque colonne du jeu de donn√©es. 2021 est l'ann√©e la plus r√©cente avec le moins de valeurs manquantes.

```{r nas_webstat}
# Regarder le nombre de donn√©es manquantes
sapply(wb, function(x) sum(length(which(is.na(x)))))
```

Nous r√©alisons pour une finir une jointure attributaire avec le fond de carte pr√©c√©demment import√© avec `rnaturalearth`. La cartographie est r√©alis√©e avec la fonction `mf_map` du package `mapsf`, dont le fonctionnement sera pr√©sent√© ult√©rieurement dans la formation. 

```{r plot_wbstats} 
# Jointure attributaire
afr <- merge(x = afr[,c("adm0_a3", "name_fr")], # fond de carte
             wb, # jeu de donn√©es de la banque mondiale
             by.x = "adm0_a3", # champ de jointure fond de carte
             by.y = "iso3c", # champ de jointure jeu de donn√©es
             all.x = TRUE) # conserver toutes les g√©om√©tries

# Carte avec la librairie map sf
library(mapsf)
mf_map(afr, # objet sf
       var = "value.2021", # variable 
       type = "choro", # type choropl√®the
       breaks = "quantile", # m√©thode de discr√©tisation
       nbreaks = 5, # nombre de classes
       leg_title = "Part de la surface totale (%)", # titre de l√©gende
       leg_adj = c(0, 2)) # ajustement position l√©gende

mf_layout(title = "Surface foresti√®re 2021",  # titre de la carte
          credits = "Source: Banque Mondiale, 2024", # sources
          scale = FALSE) # pas d'√©chelle
```


# OpenStreetMap

OpenStreetMap (OSM) est un projet de cartographie participative qui a pour but de constituer une base de donn√©es g√©ographique libre √† l‚Äô√©chelle mondiale. OSM vous permet de voir, modifier et utiliser des donn√©es g√©ographiques dans le monde entier.

Plusieurs packages permettre d'extraire, interroger et visualiser des donn√©es issues d'OSM :

- `osmextract` [@R-osmextract] : permet d'importer des donn√©es [OSM](https://www.openstreetmap.org/).   
- `osmdata` [@R-osmdata] : pour t√©l√©charger et utiliser les donn√©es d'OSM, en utilisant l'API [Overpass turbo](https://wiki.openstreetmap.org/wiki/Overpass_turbo).
- `maptiles` [@R-maptiles] : Ce package t√©l√©charge, compose et affiche des tuiles √† partir d'un grand nombre de fournisseurs (*OpenStreetMap*, *Stadia*, *Esri*, *CARTO* ou *Thunderforest*...).   
- `nominatimlite` [@R-nominatimlite] et `tidygeocoder` [@R-tidygeocoder] : Des g√©ocodeurs qui utilisent OSM, notamment. 

::: {.callout-tip}
## Objectif

Nous cherchons √† **extraire d'OSM** pour la Tunisie les g√©om√©tries suivantes :

- **D√©coupages administratifs** : D√©l√©gations et secteurs. 
- **√âquipements** : objets d√©crits avec une cl√© OSM *amenity* (√©quipements utiles et importants). 

Ces donn√©es nous permettront ensuite de **calculer les temps de parcours routiers** des **centres de secteur** vers **l'h√¥pital ou la clinique la plus accessible**. 
::: 

## Extraction et mise en forme

Le package `osmextract` [@R-osmextract] permet d‚Äôextraire de t√©l√©charger des donn√©es OSM pour une zone g√©ographique donn√©e. Cela permet aussi d‚Äô√©viter de surcharger un serveur Overpass turbo (utilis√© par le package `osmdata`) et ainsi de travailler sur des volumes de donn√©es plus importants. 

### D√©coupages administratifs

La fonction `oe_get()` permet de t√©l√©charger un extrait de la base de donn√©es OSM pour une zone particuli√®re et un type d‚Äôobjet g√©ographique. L‚Äôargument `place` correspond au nom du fichier *.pbf accessible sur le site [Geofabrik](http://download.geofabrik.de/). L‚Äôargument `extra_tag` permet de s√©lectionner les objets de la base OSM correspondant √† une cl√© particuli√®re (se r√©f√©rer √† [la documentation d‚ÄôOSM](https://wiki.openstreetmap.org/wiki/FR:%C3%89l%C3%A9ments_cartographiques) pour choisir les cl√©s).

On commence par extraire **tous les polygones et les points OSM inclus en Tunisie**. L'import d'`extra_tags` permet d'obtenir des informations suppl√©mentaires qui serviront √† filtrer la base de donn√©es. 

- **N.B.** : L'extraction peut durer quelques minutes, m√™me avec une bonne connexion

```{r import_osmextract}
#| eval: false
library(osmextract)
osm_poly <- oe_get(place = "Tunisia",
                   layer = "multipolygons",
                   extra_tags = c("amenity", "ref:tn:hasc_2", "ref:tn:codegeo",
                                  "name:fr", "name:ar"))

osm_pt <- oe_get(place = "Tunisia",
                 layer = "points",
                 extra_tags = c("amenity", "name:fr", "name:ar"))
```

On peut ensuite filtrer l'extraction en fonction des objets / champs d'int√©r√™t. 

```{r prepare_osmextract}
#| eval: false
# D√©l√©gations et secteurs
admin <- osm_poly[!is.na(osm_poly$admin_level),] # Retirer pas d'attribut de niveau hi√©rarchique
deleg <- admin[admin$admin_level == 5,] # D√©l√©gations
sect <- admin[admin$admin_level == 6,] # Secteurs

# Ne garder que les champs utiles
deleg <- deleg[,c("osm_id", "ref_tn_codegeo", "ref_tn_hasc_2", "name_ar",  
                  "name_fr", "admin_level")]
sect <- sect[,c("osm_id", "ref_tn_codegeo", "name_ar",  
                  "name_fr", "admin_level")]
```

Ce bloc de code, dont on ne d√©taillera pas le contenu ici, permet d'harmoniser le nom des champs entre les couches g√©ographiques et de disposer des d√©l√©gations et gouvernorats d'appartenance des couches g√©ographiques des secteurs et d√©l√©gations. 

```{r consolidate_osmextract}
#| eval: false

# D√©l√©gation d'appartenance du secteur
sect_pt <- st_centroid(sect) # Centroide du secteur
sect_pt <- st_intersection(sect_pt, deleg) # Intersection avec couche d√©l√©gation
sect_pt <- st_set_geometry(sect_pt, NULL) # Retirer g√©om√©tries
sect <- merge(sect, # Enrichir les secteurs du code d'appartenance de la d√©l√©gation
              sect_pt[,c("osm_id", "ref_tn_hasc_2")], 
              by = "osm_id", 
              all.x = TRUE)
sect <- sect[!duplicated(sect$osm_id),] # Retirer valeurs dupliqu√©es

# Renommer colonnes
names(sect)[2] <- "id_tn"
names(sect)[6] <- "id_hasc_deleg"
sect$id_hasc_gouv <- substr(sect$id_hasc_deleg, 1, 5) # Gouvernorat d'appartenance
names(sect)[2,6] <- (c("tn_codegeo", "int_codegeo"))
deleg$id_hasc_gouv <- substr(deleg$id_hasc_deleg, 1, 5)
```

### √âquipements

Les objets d√©crits par la cl√© *amenity* sont de nature h√©t√©rog√®nes (points, polygones). Ce bloc de code extrait les centroides des polygones et les associent √† la couche de points initiale. 

Ces couches g√©ographiques sont finalement export√©es dans un geopackage `tun_osm.gpkg`.

```{r export_preparation_osmextract}
#| eval: false

# Consolidation des g√©om√©tries
sel_poly <- osm_poly[!is.na(osm_poly$amenity),] # Retirer les objets qui n'ont pas de cl√© amenity
sel_pt <- osm_pt[!is.na(osm_pt$amenity),]
sel_poly <- st_make_valid(sel_poly) # Consolider les g√©om√©tries des polygones
sel_pt2 <- st_centroid(sel_poly) # extraire le centroide
cols <- intersect(names(sel_pt), names(sel_pt2)) # Garder les colonnes identiques
sel_pt <- rbind(sel_pt[,cols, sel_pt2[,cols]]) # Combiner points et polygones
sel_pt <- sel_pt[,c("osm_id", "amenity", "name_ar", "name_fr")]

# Exporter les couche ainsi cr√©√©es
st_write(sel_pt, "data/tun/geom/tun_osm.gpkg", layer = "poi")
st_write(deleg, "data/tun/geom/tun_osm.gpkg", layer = "deleg")
st_write(sect, "data/tun/geom/tun_osm.gpkg", layer = "sect")
```

:::{.callout-note title="Pour aller plus loin" collapse="true"}

Ce [document](https://rcarto.github.io/caRtosm/index.html) [@giraud2017] montre comment cr√©er un fond de carte avec des donn√©es OSM, extraire des objets d'int√©r√™t (bars et restaurants) avec le package `osmdata`. Il propose √©galement plusieurs pistes cartographiques pour manipuler et visualiser ces donn√©es. Notons simplement que la cartographie utilise les fonctions du package `cartography`, plus maintenu, et qu'il est conseill√© d'utiliser dor√©navant le package `mapsf`. 

![Cartographic Explorations of the OpenStreetMap Database with R (Giraud, 2017)](img/paname.png)

:::

## R√©sultats de l'extraction

D√©nombrement des 15 objets OSM les plus fr√©quents d√©crits par la cl√© *amenity* en Tunisie.

```{r import_conso_osmextract}
# Import des am√©nit√©s pr√©par√©es en amont
osm_pt <- st_read("data/data_intro/tun/geom/tun_osm.gpkg", layer = "poi", quiet = TRUE)

# Nombre de points avec le tag "amenity". 
tbl <- table(osm_pt$amenity)
tbl <- tbl[order(tbl, decreasing = TRUE)]
tbl[1:15]

# On ne prend ici que les cliniques et h√¥pitaux
osm_pt <- osm_pt[osm_pt$amenity %in% c("clinic", "hospital"), ]
```

Nombre de d√©l√©gations, secteurs et cliniques/h√¥pitaux inclus dans OSM. 

```{r import_admin_osmextract}
# Import des unit√©s territoriales pr√©par√©es en amont
deleg <- st_read("data/data_intro/tun/geom/tun_osm.gpkg", layer = "deleg", quiet = TRUE)
sect <- st_read("data/data_intro/tun/geom/tun_osm.gpkg", layer = "sect", quiet = TRUE)

# Nombre d'objets (lignes)
nrow(deleg)
nrow(sect)
nrow(osm_pt)
```

Le r√©sultat sous forme d'une carte interactive avec le package `leaflet`, qui sera pr√©sent√© ult√©rieurement dans la formation.  

```{r leaflet_osmextract}
#| code-fold: true

# Choisir la palette
library(leaflet)
pal <- colorFactor(palette = c("red", "gold"),
                   domain = c("clinic", "hospital"))

# Cartographie interactive
leaflet(osm_pt) |> # Emprise = h√¥pitaux
  addProviderTiles("OpenStreetMap.HOT") |> # Type de tuiles charg√©es
  addPolygons(data = sect, # Secteurs
              col = "white",
              fillColor = "lightgrey",
              fillOpacity = 0.7,
              weight = 1,
              popup = paste0("<b>", sect$id_tn, "<br></b>",
                             sect$name_ar, "<br>", sect$name_fr),
              group = "Secteurs")|>
  addPolygons(data = deleg, # D√©l√©gations
              col = "darkgrey",
              fill = "lightgrey",
              fillOpacity = 0,
              weight = 1.2,
              popup = paste0("<b>", deleg$id_tn, " / ",
                             deleg$id_hasc_deleg,"<br></b>",
                             deleg$name_ar, "<br>", deleg$name_fr),
              group = "D√©l√©gations") |>
  addCircleMarkers(radius = 4, # H√¥pitaux
                   stroke = FALSE,
                   color = ~ pal(amenity),
                   fillOpacity = 1,
                   popup = paste0(osm_pt$name_ar, "<br>", osm_pt$name_fr),
                   group = "Cliniques et h√¥pitaux") |>
  addLegend(pal = pal, # L√©gende pour diff√©rencier cliniques et h√¥pitaux
            values = c("clinic", "hospital"),
            opacity = 0.7,
            title = "OSM amenity",
            position = "bottomright") |>
  addLayersControl(overlayGroups = c("Secteurs", "D√©l√©gations", "Cliniques et h√¥pitaux"),
                   options = layersControlOptions(collapsed = FALSE)) 
```


## Matrices de temps et itin√©raires

Le package `osrm` (@R-osrm) sert d‚Äôinterface entre R et le service de calcul d‚Äôitin√©raire [OSRM](http://project-osrm.org/) (Luxen et Vetter, 2011). Ce package permet de calculer des matrices de temps et de distances, des itin√©raires routiers, des isochrones. Le package utilise par d√©faut le serveur de d√©mo d‚ÄôOSRM. En cas d‚Äôutilisation intensive il est fortement recommand√© d‚Äô[utiliser sa propre instance d‚ÄôOSRM avec Docker](https://rcarto.github.io/posts/build_osrm_server/).

La fonction `osrmTable()` permet de calculer des matrices de distances ou de temps par la route. Nous effectuons cette op√©ration √† partir des donn√©es extraites plus haut :

- **Origines** : centroides des secteurs de la d√©l√©gation de Sousse.
- **Destinations** : h√¥pitaux et cliniques dans un voisinage g√©ographique de 20 kilom√®tres autour de la d√©l√©gation de Sousse. 

```{r prepare_osrm}
# Origines
sel <- sect[sect$id_hasc_gouv == "TN.SS",] # Secteurs de la d√©l√©gation de Sousse
sel <- sel[!is.na(sel$osm_id),] # G√©om√©tries vides
sel <- sel[!duplicated(sel$osm_id),] # G√©om√©tries dupliqu√©es
ori <- st_centroid(sel) # Cenroide

# Consid√©rer les cliniques et h√¥pitaux dans un voisinage de 20 km autour de la d√©l√©gation
osm_pt <- st_transform(osm_pt, 2088) # Transformer en coordonn√©es planaires
sel <- st_transform(sel, 2088)
dest <- st_filter(osm_pt, st_buffer(sel, 20000), .predicate = st_intersects) # Dans un rayon de 20 km
dest <- st_transform(dest, 4326)

# Calcul de temps de trajets avec OSRM (pas grosse requ√™te)
library(osrm)
df <- osrmTable(src = ori, dst = dest, measure = "duration")

# Extraire les temps de trajet
df <- data.frame(df$durations)

# Formater la table d'une mani√®re arrangeante
colnames(df) <- as.character(dest$osm_id)
row.names(df) <- as.character(ori$osm_id)
head(df)
```

On peut ensuite extraire le temps de trajet minimal par secteur avec la fonction `apply()` 

```{r time_min_osrm}
time <- apply(df, 1, min) 
time <- data.frame(time)
time$osm_id <- row.names(time)
head(time)
```

Nous finissons par une jointure attributaire avec la couche g√©ographique des secteurs, ce qui permet de r√©aliser une repr√©sentation cartographique des r√©sultats avec le package `mapsf` qui sera pr√©sent√© ult√©rieurement dans la formation. 

```{r map_osrm}
#| code-fold: true
sel <- merge(sel, time, by = "osm_id", all.x = TRUE)
deleg <- st_transform(deleg, 2088)
dest <- st_transform(dest, 2088)

library(mapsf)
par(mfrow = c(1,1))
mf_init(sel)
mf_map(deleg, col = "lightgrey", 
       border = NA,
       add = TRUE)
mf_map(sel, 
       type = "choro",
       var = "time",
       nbreaks = 4,
       border = "white", 
       leg_title = "Minutes en voiture", 
       add = TRUE)
mf_map(deleg, col = NA, 
       border = "black",
       add = TRUE)
mf_map(dest, pch = 21, col = NA, bg = "red", add = TRUE)
mf_scale(size = 10)
mf_title("D√©l√©gation de Sousse : Temps de trajet vers l'h√¥pital ou la clinique la plus proche")
mf_credits(paste0("Source: ¬© OpenStreetMap et Contributeurs, 2024\n",
                  "NB/ Toute chose √©gale par rapport √† la compl√©tude d'OSM. Contribuez pour compl√©ter la carte le cas √©ch√©ant !"))
```


# A vous de jouer !

Vous √™tes invit√©s √† **r√©aliser un graphique et une carte simple de l'√©volution de l'√©quipement des m√©nages en ordinateur entre 2004 et 2014** dans les d√©l√©gations tunisiennes. Les √©tapes √† suivre sont les suivantes : 

**Initialisation de l'espace de travail**

- Cr√©ez un dossier sur votre espace de travail, ouvrir RStudio. 
- Cr√©ez un projet et un document Quarto (ou un script R) dans ce dossier.
- T√©l√©chargez les donn√©es (**[(https://github.com/worldregio/geounivr2024/raw/refs/heads/main/datazip/data_manipulation.zip)**) et d√©compressez l'archive dans l'espace de travail pr√©c√©demment cr√©√©. 

**Codez !**

- Importez les donn√©es avec `read.csv()` (chemin : `data/tun/data/don_del.csv`).
- Cr√©ez l'indicateur : `ordin_2014/ordin_2004 * 100.` 
- Faites un r√©sum√© statistique de la variable avec `summary()` 
- Faites un histogramme de la distribution statisitique avec `hist()`.
- Importez la couche g√©ographique des d√©l√©gations avec `st_read()` du package `sf` (chemin : `data/tun/geom/tun_admin.gpkg`, layer : delegation)
- R√©alisez une jointure attributaire avec `merge()`. Les champs communs de jointure entre les deux tables sont `del_code`.
- R√©alisez une carte de la variable d'int√©r√™t avec la fonction `plot()`

::: {.callout-tip collapse="true"}
## Une solution possible

```{r}
#  Import des donn√©es
del <- read.csv("data/data_intro/tun/data/don_del.csv", sep = ";")
head(del)

# √âvolution (indice 100) de l'√©quipement de la population en ordinateur
del$ordin_evol <- del$ordin_2014 / del$ordin_2004 * 100
head(del[,c("del_code", "del_nom_fr", "ordin_2004", "ordin_2014", "ordin_evol")])

# R√©sum√© statistique
summary(del$ordin_evol)

# Histogramme
hist(del$ordin_evol)

# Import g√©om√©tries
library(sf)
del_geom <- st_read("data/data_intro/tun/geom/tun_admin.gpkg", layer = "delegation", quiet = TRUE)

# Jointure attributaire
del_geom <- merge(del_geom, del, by = "del_code")

# Carte simple
plot(del_geom[,"ordin_evol"], breaks = "quantile",
     main = "Une g√©ographie assez marqu√©e...")
```

::: 

### Session Info

```{r}
sessionInfo()
```